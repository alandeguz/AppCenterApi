//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension EngagementAPI.Mbaas {

    /**
    Gets general data about the provisioned database
    */
    public enum DataGetOverview {

        public static let service = APIService<Response>(id: "data_getOverview", tag: "mbaas", method: "GET", path: "/v0.1/apps/{owner_name}/{app_name}/data/overview", hasBody: false, securityRequirement: SecurityRequirement(type: "APIToken", scope: ""))

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** ARM access token. */
                public var aCAuthorizationARM: String

                /** The name of the owner */
                public var ownerName: String

                /** The name of the application */
                public var appName: String

                public init(aCAuthorizationARM: String, ownerName: String, appName: String) {
                    self.aCAuthorizationARM = aCAuthorizationARM
                    self.ownerName = ownerName
                    self.appName = appName
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: DataGetOverview.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(aCAuthorizationARM: String, ownerName: String, appName: String) {
                let options = Options(aCAuthorizationARM: aCAuthorizationARM, ownerName: ownerName, appName: appName)
                self.init(options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "ownerName" + "}", with: "\(self.options.ownerName)").replacingOccurrences(of: "{" + "appName" + "}", with: "\(self.options.appName)")
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            public class Status200: APIModel {

                public enum DatabaseLocation: String, Codable {
                    case eastAsia = "East Asia"
                    case southeastAsia = "Southeast Asia"
                    case australiaCentral = "Australia Central"
                    case australiaCentral2 = "Australia Central 2"
                    case australiaEast = "Australia East"
                    case australiaSoutheast = "Australia Southeast"
                    case brazilSouth = "Brazil South"
                    case canadaCentral = "Canada Central"
                    case canadaEast = "Canada East"
                    case centralIndia = "Central India"
                    case southIndia = "South India"
                    case westIndia = "West India"
                    case northEurope = "North Europe"
                    case westEurope = "West Europe"
                    case franceCentral = "France Central"
                    case franceSouth = "France South"
                    case germanyCentral = "Germany Central"
                    case germanyNortheast = "Germany Northeast"
                    case japanEast = "Japan East"
                    case japanWest = "Japan West"
                    case koreaCentral = "Korea Central"
                    case koreaSouth = "Korea South"
                    case southAfricaNorth = "South Africa North"
                    case southAfricaWest = "South Africa West"
                    case uKSouth = "UK South"
                    case uKWest = "UK West"
                    case centralUS = "Central US"
                    case eastUS = "East US"
                    case eastUS2 = "East US 2"
                    case uSGovArizona = "US Gov Arizona"
                    case uSGovTexas = "US Gov Texas"
                    case northCentralUS = "North Central US"
                    case southCentralUS = "South Central US"
                    case westUS = "West US"
                    case westUS2 = "West US 2"
                    case westCentralUS = "West Central US"

                    public static let cases: [DatabaseLocation] = [
                      .eastAsia,
                      .southeastAsia,
                      .australiaCentral,
                      .australiaCentral2,
                      .australiaEast,
                      .australiaSoutheast,
                      .brazilSouth,
                      .canadaCentral,
                      .canadaEast,
                      .centralIndia,
                      .southIndia,
                      .westIndia,
                      .northEurope,
                      .westEurope,
                      .franceCentral,
                      .franceSouth,
                      .germanyCentral,
                      .germanyNortheast,
                      .japanEast,
                      .japanWest,
                      .koreaCentral,
                      .koreaSouth,
                      .southAfricaNorth,
                      .southAfricaWest,
                      .uKSouth,
                      .uKWest,
                      .centralUS,
                      .eastUS,
                      .eastUS2,
                      .uSGovArizona,
                      .uSGovTexas,
                      .northCentralUS,
                      .southCentralUS,
                      .westUS,
                      .westUS2,
                      .westCentralUS,
                    ]
                }

                public var accountName: String?

                public var databaseId: String?

                public var databaseLocation: DatabaseLocation?

                public var throughput: Int?

                public init(accountName: String? = nil, databaseId: String? = nil, databaseLocation: DatabaseLocation? = nil, throughput: Int? = nil) {
                    self.accountName = accountName
                    self.databaseId = databaseId
                    self.databaseLocation = databaseLocation
                    self.throughput = throughput
                }

                private enum CodingKeys: String, CodingKey {
                    case accountName
                    case databaseId
                    case databaseLocation
                    case throughput
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    accountName = try container.decodeIfPresent(.accountName)
                    databaseId = try container.decodeIfPresent(.databaseId)
                    databaseLocation = try container.decodeIfPresent(.databaseLocation)
                    throughput = try container.decodeIfPresent(.throughput)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(accountName, forKey: .accountName)
                    try container.encodeIfPresent(databaseId, forKey: .databaseId)
                    try container.encodeIfPresent(databaseLocation, forKey: .databaseLocation)
                    try container.encodeIfPresent(throughput, forKey: .throughput)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.accountName == object.accountName else { return false }
                  guard self.databaseId == object.databaseId else { return false }
                  guard self.databaseLocation == object.databaseLocation else { return false }
                  guard self.throughput == object.throughput else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public class Status500: APIModel {

                public var error: ErrorType

                public class ErrorType: APIModel {

                    public enum Code: String, Codable {
                        case badRequest = "BadRequest"
                        case conflict = "Conflict"
                        case notAcceptable = "NotAcceptable"
                        case notFound = "NotFound"
                        case internalServerError = "InternalServerError"
                        case unauthorized = "Unauthorized"
                        case tooManyRequests = "TooManyRequests"

                        public static let cases: [Code] = [
                          .badRequest,
                          .conflict,
                          .notAcceptable,
                          .notFound,
                          .internalServerError,
                          .unauthorized,
                          .tooManyRequests,
                        ]
                    }

                    public var code: Code

                    public var message: String

                    public init(code: Code, message: String) {
                        self.code = code
                        self.message = message
                    }

                    private enum CodingKeys: String, CodingKey {
                        case code
                        case message
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)

                        code = try container.decode(.code)
                        message = try container.decode(.message)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: CodingKeys.self)

                        try container.encode(code, forKey: .code)
                        try container.encode(message, forKey: .message)
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? ErrorType else { return false }
                      guard self.code == object.code else { return false }
                      guard self.message == object.message else { return false }
                      return true
                    }

                    public static func == (lhs: ErrorType, rhs: ErrorType) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(error: ErrorType) {
                    self.error = error
                }

                private enum CodingKeys: String, CodingKey {
                    case error
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    error = try container.decode(.error)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encode(error, forKey: .error)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status500 else { return false }
                  guard self.error == object.error else { return false }
                  return true
                }

                public static func == (lhs: Status500, rhs: Status500) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** Success */
            case status200(Status200)

            /** Server Error */
            case status500(Status500)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var failure: Status500? {
                switch self {
                case .status500(let response): return response
                default: return nil
                }
            }

            /// either success or failure value. Success is anything in the 200..<300 status code range
            public var responseResult: APIResponseResult<Status200, Status500> {
                if let successValue = success {
                    return .success(successValue)
                } else if let failureValue = failure {
                    return .failure(failureValue)
                } else {
                    fatalError("Response does not have success or failure response")
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .status500(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .status500: return 500
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .status500: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                case 500: self = try .status500(decoder.decode(Status500.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
