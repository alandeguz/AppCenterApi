//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension EngagementAPI.Mbaas {

    /**
    Creates Cosmos DB or attaches an existing one
    */
    public enum DataPostResourceProvisioning {

        public static let service = APIService<Response>(id: "data_postResourceProvisioning", tag: "mbaas", method: "POST", path: "/v0.1/apps/{owner_name}/{app_name}/data/resource_provisioning", hasBody: true, securityRequirement: SecurityRequirement(type: "APIToken", scope: ""))

        public final class Request: APIRequest<Response> {

            public class ProvisionDatabaseParameters: APIModel {

                public enum ResourceRegion: String, Codable {
                    case eastAsia = "East Asia"
                    case southeastAsia = "Southeast Asia"
                    case australiaCentral = "Australia Central"
                    case australiaCentral2 = "Australia Central 2"
                    case australiaEast = "Australia East"
                    case australiaSoutheast = "Australia Southeast"
                    case brazilSouth = "Brazil South"
                    case canadaCentral = "Canada Central"
                    case canadaEast = "Canada East"
                    case centralIndia = "Central India"
                    case southIndia = "South India"
                    case westIndia = "West India"
                    case northEurope = "North Europe"
                    case westEurope = "West Europe"
                    case franceCentral = "France Central"
                    case franceSouth = "France South"
                    case germanyCentral = "Germany Central"
                    case germanyNortheast = "Germany Northeast"
                    case japanEast = "Japan East"
                    case japanWest = "Japan West"
                    case koreaCentral = "Korea Central"
                    case koreaSouth = "Korea South"
                    case southAfricaNorth = "South Africa North"
                    case southAfricaWest = "South Africa West"
                    case uKSouth = "UK South"
                    case uKWest = "UK West"
                    case centralUS = "Central US"
                    case eastUS = "East US"
                    case eastUS2 = "East US 2"
                    case uSGovArizona = "US Gov Arizona"
                    case uSGovTexas = "US Gov Texas"
                    case northCentralUS = "North Central US"
                    case southCentralUS = "South Central US"
                    case westUS = "West US"
                    case westUS2 = "West US 2"
                    case westCentralUS = "West Central US"

                    public static let cases: [ResourceRegion] = [
                      .eastAsia,
                      .southeastAsia,
                      .australiaCentral,
                      .australiaCentral2,
                      .australiaEast,
                      .australiaSoutheast,
                      .brazilSouth,
                      .canadaCentral,
                      .canadaEast,
                      .centralIndia,
                      .southIndia,
                      .westIndia,
                      .northEurope,
                      .westEurope,
                      .franceCentral,
                      .franceSouth,
                      .germanyCentral,
                      .germanyNortheast,
                      .japanEast,
                      .japanWest,
                      .koreaCentral,
                      .koreaSouth,
                      .southAfricaNorth,
                      .southAfricaWest,
                      .uKSouth,
                      .uKWest,
                      .centralUS,
                      .eastUS,
                      .eastUS2,
                      .uSGovArizona,
                      .uSGovTexas,
                      .northCentralUS,
                      .southCentralUS,
                      .westUS,
                      .westUS2,
                      .westCentralUS,
                    ]
                }

                public var accountName: String?

                public var collection: String?

                public var database: String?

                public var databaseConnectionString: String?

                public var requestUnits: Int?

                public var resourceRegion: ResourceRegion?

                public var subscriptionId: String?

                public init(accountName: String? = nil, collection: String? = nil, database: String? = nil, databaseConnectionString: String? = nil, requestUnits: Int? = nil, resourceRegion: ResourceRegion? = nil, subscriptionId: String? = nil) {
                    self.accountName = accountName
                    self.collection = collection
                    self.database = database
                    self.databaseConnectionString = databaseConnectionString
                    self.requestUnits = requestUnits
                    self.resourceRegion = resourceRegion
                    self.subscriptionId = subscriptionId
                }

                private enum CodingKeys: String, CodingKey {
                    case accountName
                    case collection
                    case database
                    case databaseConnectionString
                    case requestUnits
                    case resourceRegion
                    case subscriptionId
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    accountName = try container.decodeIfPresent(.accountName)
                    collection = try container.decodeIfPresent(.collection)
                    database = try container.decodeIfPresent(.database)
                    databaseConnectionString = try container.decodeIfPresent(.databaseConnectionString)
                    requestUnits = try container.decodeIfPresent(.requestUnits)
                    resourceRegion = try container.decodeIfPresent(.resourceRegion)
                    subscriptionId = try container.decodeIfPresent(.subscriptionId)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(accountName, forKey: .accountName)
                    try container.encodeIfPresent(collection, forKey: .collection)
                    try container.encodeIfPresent(database, forKey: .database)
                    try container.encodeIfPresent(databaseConnectionString, forKey: .databaseConnectionString)
                    try container.encodeIfPresent(requestUnits, forKey: .requestUnits)
                    try container.encodeIfPresent(resourceRegion, forKey: .resourceRegion)
                    try container.encodeIfPresent(subscriptionId, forKey: .subscriptionId)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? ProvisionDatabaseParameters else { return false }
                  guard self.accountName == object.accountName else { return false }
                  guard self.collection == object.collection else { return false }
                  guard self.database == object.database else { return false }
                  guard self.databaseConnectionString == object.databaseConnectionString else { return false }
                  guard self.requestUnits == object.requestUnits else { return false }
                  guard self.resourceRegion == object.resourceRegion else { return false }
                  guard self.subscriptionId == object.subscriptionId else { return false }
                  return true
                }

                public static func == (lhs: ProvisionDatabaseParameters, rhs: ProvisionDatabaseParameters) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public struct Options {

                public var aCAuthorizationARM: String

                /** The name of the owner */
                public var ownerName: String

                /** The name of the application */
                public var appName: String

                public init(aCAuthorizationARM: String, ownerName: String, appName: String) {
                    self.aCAuthorizationARM = aCAuthorizationARM
                    self.ownerName = ownerName
                    self.appName = appName
                }
            }

            public var options: Options

            public var provisionDatabaseParameters: ProvisionDatabaseParameters?

            public init(provisionDatabaseParameters: ProvisionDatabaseParameters?, options: Options) {
                self.provisionDatabaseParameters = provisionDatabaseParameters
                self.options = options
                super.init(service: DataPostResourceProvisioning.service) {
                    let jsonEncoder = JSONEncoder()
                    return try jsonEncoder.encode(provisionDatabaseParameters)
                }
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(aCAuthorizationARM: String, provisionDatabaseParameters: ProvisionDatabaseParameters? = nil, ownerName: String, appName: String) {
                let options = Options(aCAuthorizationARM: aCAuthorizationARM, ownerName: ownerName, appName: appName)
                self.init(provisionDatabaseParameters: provisionDatabaseParameters, options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "ownerName" + "}", with: "\(self.options.ownerName)").replacingOccurrences(of: "{" + "appName" + "}", with: "\(self.options.appName)")
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            public class Status202: APIModel {

                public enum Status: String, Codable {
                    case empty = "Empty"
                    case accepted = "Accepted"
                    case creating = "Creating"
                    case connected = "Connected"
                    case invalid = "Invalid"

                    public static let cases: [Status] = [
                      .empty,
                      .accepted,
                      .creating,
                      .connected,
                      .invalid,
                    ]
                }

                public var status: Status

                public var message: String?

                public init(status: Status, message: String? = nil) {
                    self.status = status
                    self.message = message
                }

                private enum CodingKeys: String, CodingKey {
                    case status
                    case message
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    status = try container.decode(.status)
                    message = try container.decodeIfPresent(.message)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encode(status, forKey: .status)
                    try container.encodeIfPresent(message, forKey: .message)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status202 else { return false }
                  guard self.status == object.status else { return false }
                  guard self.message == object.message else { return false }
                  return true
                }

                public static func == (lhs: Status202, rhs: Status202) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public class Status400: APIModel {

                public var error: ErrorType

                public class ErrorType: APIModel {

                    public enum Code: String, Codable {
                        case badRequest = "BadRequest"
                        case conflict = "Conflict"
                        case notAcceptable = "NotAcceptable"
                        case notFound = "NotFound"
                        case internalServerError = "InternalServerError"
                        case unauthorized = "Unauthorized"
                        case tooManyRequests = "TooManyRequests"

                        public static let cases: [Code] = [
                          .badRequest,
                          .conflict,
                          .notAcceptable,
                          .notFound,
                          .internalServerError,
                          .unauthorized,
                          .tooManyRequests,
                        ]
                    }

                    public var code: Code

                    public var message: String

                    public init(code: Code, message: String) {
                        self.code = code
                        self.message = message
                    }

                    private enum CodingKeys: String, CodingKey {
                        case code
                        case message
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)

                        code = try container.decode(.code)
                        message = try container.decode(.message)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: CodingKeys.self)

                        try container.encode(code, forKey: .code)
                        try container.encode(message, forKey: .message)
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? ErrorType else { return false }
                      guard self.code == object.code else { return false }
                      guard self.message == object.message else { return false }
                      return true
                    }

                    public static func == (lhs: ErrorType, rhs: ErrorType) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(error: ErrorType) {
                    self.error = error
                }

                private enum CodingKeys: String, CodingKey {
                    case error
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    error = try container.decode(.error)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encode(error, forKey: .error)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status400 else { return false }
                  guard self.error == object.error else { return false }
                  return true
                }

                public static func == (lhs: Status400, rhs: Status400) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public class Status500: APIModel {

                public var error: ErrorType

                public class ErrorType: APIModel {

                    public enum Code: String, Codable {
                        case badRequest = "BadRequest"
                        case conflict = "Conflict"
                        case notAcceptable = "NotAcceptable"
                        case notFound = "NotFound"
                        case internalServerError = "InternalServerError"
                        case unauthorized = "Unauthorized"
                        case tooManyRequests = "TooManyRequests"

                        public static let cases: [Code] = [
                          .badRequest,
                          .conflict,
                          .notAcceptable,
                          .notFound,
                          .internalServerError,
                          .unauthorized,
                          .tooManyRequests,
                        ]
                    }

                    public var code: Code

                    public var message: String

                    public init(code: Code, message: String) {
                        self.code = code
                        self.message = message
                    }

                    private enum CodingKeys: String, CodingKey {
                        case code
                        case message
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)

                        code = try container.decode(.code)
                        message = try container.decode(.message)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: CodingKeys.self)

                        try container.encode(code, forKey: .code)
                        try container.encode(message, forKey: .message)
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? ErrorType else { return false }
                      guard self.code == object.code else { return false }
                      guard self.message == object.message else { return false }
                      return true
                    }

                    public static func == (lhs: ErrorType, rhs: ErrorType) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(error: ErrorType) {
                    self.error = error
                }

                private enum CodingKeys: String, CodingKey {
                    case error
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    error = try container.decode(.error)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encode(error, forKey: .error)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status500 else { return false }
                  guard self.error == object.error else { return false }
                  return true
                }

                public static func == (lhs: Status500, rhs: Status500) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status202

            /** Request Accepted */
            case status202(Status202)

            /** Bad Request */
            case status400(Status400)

            /** Server Error */
            case status500(Status500)

            public var success: Status202? {
                switch self {
                case .status202(let response): return response
                default: return nil
                }
            }

            public var response: Any {
                switch self {
                case .status202(let response): return response
                case .status400(let response): return response
                case .status500(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status202: return 202
                case .status400: return 400
                case .status500: return 500
                }
            }

            public var successful: Bool {
                switch self {
                case .status202: return true
                case .status400: return false
                case .status500: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 202: self = try .status202(decoder.decode(Status202.self, from: data))
                case 400: self = try .status400(decoder.decode(Status400.self, from: data))
                case 500: self = try .status500(decoder.decode(Status500.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
