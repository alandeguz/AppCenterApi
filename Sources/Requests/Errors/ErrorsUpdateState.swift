//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension EngagementAPI.Errors {

    /**
    Update error group state
    */
    public enum ErrorsUpdateState {

        public static let service = APIService<Response>(id: "Errors_UpdateState", tag: "errors", method: "PATCH", path: "/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}", hasBody: true, securityRequirement: SecurityRequirement(type: "APIToken", scope: ""))

        public final class Request: APIRequest<Response> {

            /** Update error group state */
            public class ErrorGroupState: APIModel {

                public var state: GroupStatus

                public var annotation: String?

                public init(state: GroupStatus, annotation: String? = nil) {
                    self.state = state
                    self.annotation = annotation
                }

                private enum CodingKeys: String, CodingKey {
                    case state
                    case annotation
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    state = try container.decode(.state)
                    annotation = try container.decodeIfPresent(.annotation)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encode(state, forKey: .state)
                    try container.encodeIfPresent(annotation, forKey: .annotation)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? ErrorGroupState else { return false }
                  guard self.state == object.state else { return false }
                  guard self.annotation == object.annotation else { return false }
                  return true
                }

                public static func == (lhs: ErrorGroupState, rhs: ErrorGroupState) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public struct Options {

                /** The id of the error group */
                public var errorGroupId: String

                /** The name of the owner */
                public var ownerName: String

                /** The name of the application */
                public var appName: String

                public init(errorGroupId: String, ownerName: String, appName: String) {
                    self.errorGroupId = errorGroupId
                    self.ownerName = ownerName
                    self.appName = appName
                }
            }

            public var options: Options

            public var errorGroupState: ErrorGroupState

            public init(errorGroupState: ErrorGroupState, options: Options) {
                self.errorGroupState = errorGroupState
                self.options = options
                super.init(service: ErrorsUpdateState.service) {
                    let jsonEncoder = JSONEncoder()
                    return try jsonEncoder.encode(errorGroupState)
                }
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(errorGroupId: String, errorGroupState: ErrorGroupState, ownerName: String, appName: String) {
                let options = Options(errorGroupId: errorGroupId, ownerName: ownerName, appName: appName)
                self.init(errorGroupState: errorGroupState, options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "errorGroupId" + "}", with: "\(self.options.errorGroupId)").replacingOccurrences(of: "{" + "ownerName" + "}", with: "\(self.options.ownerName)").replacingOccurrences(of: "{" + "appName" + "}", with: "\(self.options.appName)")
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Update error group state */
            public class Status200: APIModel {

                public var errorGroupId: String

                public var appVersion: String

                public var count: Int

                public var deviceCount: Int

                public var firstOccurrence: DateTime

                public var lastOccurrence: DateTime

                public var appBuild: String?

                public var codeRaw: String?

                public var exceptionAppCode: Bool?

                public var exceptionClassMethod: Bool?

                public var exceptionClassName: String?

                public var exceptionFile: String?

                public var exceptionLine: String?

                public var exceptionMessage: String?

                public var exceptionMethod: String?

                public var exceptionType: String?

                public var hidden: Bool?

                public var reasonFrames: [ReasonFrames]?

                public init(errorGroupId: String, appVersion: String, count: Int, deviceCount: Int, firstOccurrence: DateTime, lastOccurrence: DateTime, appBuild: String? = nil, codeRaw: String? = nil, exceptionAppCode: Bool? = nil, exceptionClassMethod: Bool? = nil, exceptionClassName: String? = nil, exceptionFile: String? = nil, exceptionLine: String? = nil, exceptionMessage: String? = nil, exceptionMethod: String? = nil, exceptionType: String? = nil, hidden: Bool? = nil, reasonFrames: [ReasonFrames]? = nil) {
                    self.errorGroupId = errorGroupId
                    self.appVersion = appVersion
                    self.count = count
                    self.deviceCount = deviceCount
                    self.firstOccurrence = firstOccurrence
                    self.lastOccurrence = lastOccurrence
                    self.appBuild = appBuild
                    self.codeRaw = codeRaw
                    self.exceptionAppCode = exceptionAppCode
                    self.exceptionClassMethod = exceptionClassMethod
                    self.exceptionClassName = exceptionClassName
                    self.exceptionFile = exceptionFile
                    self.exceptionLine = exceptionLine
                    self.exceptionMessage = exceptionMessage
                    self.exceptionMethod = exceptionMethod
                    self.exceptionType = exceptionType
                    self.hidden = hidden
                    self.reasonFrames = reasonFrames
                }

                private enum CodingKeys: String, CodingKey {
                    case errorGroupId
                    case appVersion
                    case count
                    case deviceCount
                    case firstOccurrence
                    case lastOccurrence
                    case appBuild
                    case codeRaw
                    case exceptionAppCode
                    case exceptionClassMethod
                    case exceptionClassName
                    case exceptionFile
                    case exceptionLine
                    case exceptionMessage
                    case exceptionMethod
                    case exceptionType
                    case hidden
                    case reasonFrames
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    errorGroupId = try container.decode(.errorGroupId)
                    appVersion = try container.decode(.appVersion)
                    count = try container.decode(.count)
                    deviceCount = try container.decode(.deviceCount)
                    firstOccurrence = try container.decode(.firstOccurrence)
                    lastOccurrence = try container.decode(.lastOccurrence)
                    appBuild = try container.decodeIfPresent(.appBuild)
                    codeRaw = try container.decodeIfPresent(.codeRaw)
                    exceptionAppCode = try container.decodeIfPresent(.exceptionAppCode)
                    exceptionClassMethod = try container.decodeIfPresent(.exceptionClassMethod)
                    exceptionClassName = try container.decodeIfPresent(.exceptionClassName)
                    exceptionFile = try container.decodeIfPresent(.exceptionFile)
                    exceptionLine = try container.decodeIfPresent(.exceptionLine)
                    exceptionMessage = try container.decodeIfPresent(.exceptionMessage)
                    exceptionMethod = try container.decodeIfPresent(.exceptionMethod)
                    exceptionType = try container.decodeIfPresent(.exceptionType)
                    hidden = try container.decodeIfPresent(.hidden)
                    reasonFrames = try container.decodeArrayIfPresent(.reasonFrames)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encode(errorGroupId, forKey: .errorGroupId)
                    try container.encode(appVersion, forKey: .appVersion)
                    try container.encode(count, forKey: .count)
                    try container.encode(deviceCount, forKey: .deviceCount)
                    try container.encode(firstOccurrence, forKey: .firstOccurrence)
                    try container.encode(lastOccurrence, forKey: .lastOccurrence)
                    try container.encodeIfPresent(appBuild, forKey: .appBuild)
                    try container.encodeIfPresent(codeRaw, forKey: .codeRaw)
                    try container.encodeIfPresent(exceptionAppCode, forKey: .exceptionAppCode)
                    try container.encodeIfPresent(exceptionClassMethod, forKey: .exceptionClassMethod)
                    try container.encodeIfPresent(exceptionClassName, forKey: .exceptionClassName)
                    try container.encodeIfPresent(exceptionFile, forKey: .exceptionFile)
                    try container.encodeIfPresent(exceptionLine, forKey: .exceptionLine)
                    try container.encodeIfPresent(exceptionMessage, forKey: .exceptionMessage)
                    try container.encodeIfPresent(exceptionMethod, forKey: .exceptionMethod)
                    try container.encodeIfPresent(exceptionType, forKey: .exceptionType)
                    try container.encodeIfPresent(hidden, forKey: .hidden)
                    try container.encodeIfPresent(reasonFrames, forKey: .reasonFrames)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.errorGroupId == object.errorGroupId else { return false }
                  guard self.appVersion == object.appVersion else { return false }
                  guard self.count == object.count else { return false }
                  guard self.deviceCount == object.deviceCount else { return false }
                  guard self.firstOccurrence == object.firstOccurrence else { return false }
                  guard self.lastOccurrence == object.lastOccurrence else { return false }
                  guard self.appBuild == object.appBuild else { return false }
                  guard self.codeRaw == object.codeRaw else { return false }
                  guard self.exceptionAppCode == object.exceptionAppCode else { return false }
                  guard self.exceptionClassMethod == object.exceptionClassMethod else { return false }
                  guard self.exceptionClassName == object.exceptionClassName else { return false }
                  guard self.exceptionFile == object.exceptionFile else { return false }
                  guard self.exceptionLine == object.exceptionLine else { return false }
                  guard self.exceptionMessage == object.exceptionMessage else { return false }
                  guard self.exceptionMethod == object.exceptionMethod else { return false }
                  guard self.exceptionType == object.exceptionType else { return false }
                  guard self.hidden == object.hidden else { return false }
                  guard self.reasonFrames == object.reasonFrames else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Update error group state */
            public class DefaultResponse: APIModel {

                public var error: ErrorType

                /** Update error group state */
                public class ErrorType: APIModel {

                    /** Update error group state */
                    public enum Code: String, Codable {
                        case badRequest = "BadRequest"
                        case conflict = "Conflict"
                        case notAcceptable = "NotAcceptable"
                        case notFound = "NotFound"
                        case internalServerError = "InternalServerError"
                        case unauthorized = "Unauthorized"
                        case tooManyRequests = "TooManyRequests"

                        public static let cases: [Code] = [
                          .badRequest,
                          .conflict,
                          .notAcceptable,
                          .notFound,
                          .internalServerError,
                          .unauthorized,
                          .tooManyRequests,
                        ]
                    }

                    public var code: Code

                    public var message: String

                    public init(code: Code, message: String) {
                        self.code = code
                        self.message = message
                    }

                    private enum CodingKeys: String, CodingKey {
                        case code
                        case message
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)

                        code = try container.decode(.code)
                        message = try container.decode(.message)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: CodingKeys.self)

                        try container.encode(code, forKey: .code)
                        try container.encode(message, forKey: .message)
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? ErrorType else { return false }
                      guard self.code == object.code else { return false }
                      guard self.message == object.message else { return false }
                      return true
                    }

                    public static func == (lhs: ErrorType, rhs: ErrorType) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(error: ErrorType) {
                    self.error = error
                }

                private enum CodingKeys: String, CodingKey {
                    case error
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    error = try container.decode(.error)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encode(error, forKey: .error)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? DefaultResponse else { return false }
                  guard self.error == object.error else { return false }
                  return true
                }

                public static func == (lhs: DefaultResponse, rhs: DefaultResponse) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** Error group details */
            case status200(Status200)

            /** Error code with reason */
            case defaultResponse(statusCode: Int, DefaultResponse)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var failure: DefaultResponse? {
                switch self {
                case .defaultResponse(_, let response): return response
                default: return nil
                }
            }

            /// either success or failure value. Success is anything in the 200..<300 status code range
            public var responseResult: APIResponseResult<Status200, DefaultResponse> {
                if let successValue = success {
                    return .success(successValue)
                } else if let failureValue = failure {
                    return .failure(failureValue)
                } else {
                    fatalError("Response does not have success or failure response")
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .defaultResponse(_, let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .defaultResponse(let statusCode, _): return statusCode
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .defaultResponse: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: self = try .defaultResponse(statusCode: statusCode, decoder.decode(DefaultResponse.self, from: data))
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
