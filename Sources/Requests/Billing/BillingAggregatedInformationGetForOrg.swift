//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension EngagementAPI.Billing {

    /**
    Aggregated Billing Information for a given Organization.
    */
    public enum BillingAggregatedInformationGetForOrg {

        public static let service = APIService<Response>(id: "billingAggregatedInformation_getForOrg", tag: "billing", method: "GET", path: "/v0.1/orgs/{orgName}/billing/aggregated", hasBody: false, securityRequirement: SecurityRequirement(type: "APIToken", scope: ""))

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** The name of the Organization */
                public var orgName: String

                /** Type of service that should be included in the Billing Information */
                public var service: ServiceTypeFilterParameter?

                /** Type of period that should be included in the Billing Information */
                public var period: PeriodTypeFilterParameter?

                /** Controls whether the API should show the original plan when Azure Subscription is not enabled */
                public var showOriginalPlans: Bool?

                public init(orgName: String, service: ServiceTypeFilterParameter? = nil, period: PeriodTypeFilterParameter? = nil, showOriginalPlans: Bool? = nil) {
                    self.orgName = orgName
                    self.service = service
                    self.period = period
                    self.showOriginalPlans = showOriginalPlans
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: BillingAggregatedInformationGetForOrg.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(orgName: String, service: ServiceTypeFilterParameter? = nil, period: PeriodTypeFilterParameter? = nil, showOriginalPlans: Bool? = nil) {
                let options = Options(orgName: orgName, service: service, period: period, showOriginalPlans: showOriginalPlans)
                self.init(options: options)
            }

            public override var path: String {
                return super.path.replacingOccurrences(of: "{" + "orgName" + "}", with: "\(self.options.orgName)")
            }

            public override var parameters: [String: Any] {
                var params: [String: Any] = [:]
                if let service = options.service?.encode() {
                  params["service"] = service
                }
                if let period = options.period?.encode() {
                  params["period"] = period
                }
                if let showOriginalPlans = options.showOriginalPlans {
                  params["showOriginalPlans"] = showOriginalPlans
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** Aggregated Billing Information for a given Organization. */
            public class Status200: APIModel {

                /** State of the Azure subscription used for billing */
                public enum AzureSubscriptionState: String, Codable {
                    case enabled = "Enabled"
                    case disabled = "Disabled"
                    case notSet = "NotSet"

                    public static let cases: [AzureSubscriptionState] = [
                      .enabled,
                      .disabled,
                      .notSet,
                    ]
                }

                /** Unique identifier for the Azure subscription used for billing */
                public var azureSubscriptionId: String?

                /** State of the Azure subscription used for billing */
                public var azureSubscriptionState: AzureSubscriptionState?

                /** Billing Plans section in the Billing Information */
                public var billingPlans: BillingPlans?

                /** ID of the user or organization */
                public var id: String?

                /** The ISO 8601 datetime of last modification */
                public var timestamp: String?

                /** Usage section in the Billing Information */
                public var usage: Usage?

                /** Version of the Billing Information schema */
                public var version: String?

                /** Aggregated Billing Information for a given Organization. */
                public class BillingPlans: APIModel {

                    /** Billing Plans for a single service */
                    public var buildService: BuildService?

                    /** Billing Plans for a single service */
                    public var testService: TestService?

                    /** Aggregated Billing Information for a given Organization. */
                    public class BuildService: APIModel {

                        /** Can customer select trial plan for that service (if it exists)? */
                        public var canSelectTrialPlan: Bool?

                        /** Billing plans for a given period */
                        public var currentBillingPeriod: CurrentBillingPeriod?

                        /** Expiration time of the last selected trial plan. Will be null if trial plan was not used. */
                        public var lastTrialPlanExpirationTime: String?

                        /** Aggregated Billing Information for a given Organization. */
                        public class CurrentBillingPeriod: APIModel {

                            /** Selection of a billing plan */
                            public var byAccount: ByAccount?

                            /** Exclusive end of the period. */
                            public var endTime: String?

                            /** Inclusive start of the period */
                            public var startTime: String?

                            /** Aggregated Billing Information for a given Organization. */
                            public class ByAccount: APIModel {

                                /** Number of instances of the billing plan. */
                                public var count: Int?

                                /** Billing Plan */
                                public var plan: Plan?

                                /** Aggregated Billing Information for a given Organization. */
                                public class Plan: APIModel {

                                    /** Service that receives payments for this billing plan. */
                                    public enum PaymentSource: String, Codable {
                                        case none = "None"
                                        case appCenter = "AppCenter"
                                        case gitHub = "GitHub"
                                        case xtc = "Xtc"

                                        public static let cases: [PaymentSource] = [
                                          .none,
                                          .appCenter,
                                          .gitHub,
                                          .xtc,
                                        ]
                                    }

                                    /** Name of the service that the plan applies to. */
                                    public enum Service: String, Codable {
                                        case build = "Build"
                                        case test = "Test"

                                        public static let cases: [Service] = [
                                          .build,
                                          .test,
                                        ]
                                    }

                                    /** Collection of attribute values. */
                                    public var attributes: [String: [String: Any]]?

                                    /** The Billing Plan ID */
                                    public var id: String?

                                    /** A collection of named numeric values */
                                    public var limits: [String: Double]?

                                    public var parentId: String?

                                    /** Service that receives payments for this billing plan. */
                                    public var paymentSource: PaymentSource?

                                    /** Price of the Billing Plan */
                                    public var price: Double?

                                    /** Name of the service that the plan applies to. */
                                    public var service: Service?

                                    /** Version of the Billing Plan schema */
                                    public var version: String?

                                    public init(attributes: [String: [String: Any]]? = nil, id: String? = nil, limits: [String: Double]? = nil, parentId: String? = nil, paymentSource: PaymentSource? = nil, price: Double? = nil, service: Service? = nil, version: String? = nil) {
                                        self.attributes = attributes
                                        self.id = id
                                        self.limits = limits
                                        self.parentId = parentId
                                        self.paymentSource = paymentSource
                                        self.price = price
                                        self.service = service
                                        self.version = version
                                    }

                                    private enum CodingKeys: String, CodingKey {
                                        case attributes
                                        case id
                                        case limits
                                        case parentId
                                        case paymentSource
                                        case price
                                        case service
                                        case version
                                    }

                                    public required init(from decoder: Decoder) throws {
                                        let container = try decoder.container(keyedBy: CodingKeys.self)

                                        attributes = try container.decodeAnyIfPresent(.attributes)
                                        id = try container.decodeIfPresent(.id)
                                        limits = try container.decodeIfPresent(.limits)
                                        parentId = try container.decodeIfPresent(.parentId)
                                        paymentSource = try container.decodeIfPresent(.paymentSource)
                                        price = try container.decodeIfPresent(.price)
                                        service = try container.decodeIfPresent(.service)
                                        version = try container.decodeIfPresent(.version)
                                    }

                                    public func encode(to encoder: Encoder) throws {
                                        var container = encoder.container(keyedBy: CodingKeys.self)

                                        try container.encodeAnyIfPresent(attributes, forKey: .attributes)
                                        try container.encodeIfPresent(id, forKey: .id)
                                        try container.encodeIfPresent(limits, forKey: .limits)
                                        try container.encodeIfPresent(parentId, forKey: .parentId)
                                        try container.encodeIfPresent(paymentSource, forKey: .paymentSource)
                                        try container.encodeIfPresent(price, forKey: .price)
                                        try container.encodeIfPresent(service, forKey: .service)
                                        try container.encodeIfPresent(version, forKey: .version)
                                    }

                                    public func isEqual(to object: Any?) -> Bool {
                                      guard let object = object as? Plan else { return false }
                                      guard self.attributes == object.attributes else { return false }
                                      guard self.id == object.id else { return false }
                                      guard self.limits == object.limits else { return false }
                                      guard self.parentId == object.parentId else { return false }
                                      guard self.paymentSource == object.paymentSource else { return false }
                                      guard self.price == object.price else { return false }
                                      guard self.service == object.service else { return false }
                                      guard self.version == object.version else { return false }
                                      return true
                                    }

                                    public static func == (lhs: Plan, rhs: Plan) -> Bool {
                                        return lhs.isEqual(to: rhs)
                                    }
                                }

                                public init(count: Int? = nil, plan: Plan? = nil) {
                                    self.count = count
                                    self.plan = plan
                                }

                                private enum CodingKeys: String, CodingKey {
                                    case count
                                    case plan
                                }

                                public required init(from decoder: Decoder) throws {
                                    let container = try decoder.container(keyedBy: CodingKeys.self)

                                    count = try container.decodeIfPresent(.count)
                                    plan = try container.decodeIfPresent(.plan)
                                }

                                public func encode(to encoder: Encoder) throws {
                                    var container = encoder.container(keyedBy: CodingKeys.self)

                                    try container.encodeIfPresent(count, forKey: .count)
                                    try container.encodeIfPresent(plan, forKey: .plan)
                                }

                                public func isEqual(to object: Any?) -> Bool {
                                  guard let object = object as? ByAccount else { return false }
                                  guard self.count == object.count else { return false }
                                  guard self.plan == object.plan else { return false }
                                  return true
                                }

                                public static func == (lhs: ByAccount, rhs: ByAccount) -> Bool {
                                    return lhs.isEqual(to: rhs)
                                }
                            }

                            public init(byAccount: ByAccount? = nil, endTime: String? = nil, startTime: String? = nil) {
                                self.byAccount = byAccount
                                self.endTime = endTime
                                self.startTime = startTime
                            }

                            private enum CodingKeys: String, CodingKey {
                                case byAccount
                                case endTime
                                case startTime
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: CodingKeys.self)

                                byAccount = try container.decodeIfPresent(.byAccount)
                                endTime = try container.decodeIfPresent(.endTime)
                                startTime = try container.decodeIfPresent(.startTime)
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: CodingKeys.self)

                                try container.encodeIfPresent(byAccount, forKey: .byAccount)
                                try container.encodeIfPresent(endTime, forKey: .endTime)
                                try container.encodeIfPresent(startTime, forKey: .startTime)
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? CurrentBillingPeriod else { return false }
                              guard self.byAccount == object.byAccount else { return false }
                              guard self.endTime == object.endTime else { return false }
                              guard self.startTime == object.startTime else { return false }
                              return true
                            }

                            public static func == (lhs: CurrentBillingPeriod, rhs: CurrentBillingPeriod) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(canSelectTrialPlan: Bool? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil, lastTrialPlanExpirationTime: String? = nil) {
                            self.canSelectTrialPlan = canSelectTrialPlan
                            self.currentBillingPeriod = currentBillingPeriod
                            self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                        }

                        private enum CodingKeys: String, CodingKey {
                            case canSelectTrialPlan
                            case currentBillingPeriod
                            case lastTrialPlanExpirationTime
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: CodingKeys.self)

                            canSelectTrialPlan = try container.decodeIfPresent(.canSelectTrialPlan)
                            currentBillingPeriod = try container.decodeIfPresent(.currentBillingPeriod)
                            lastTrialPlanExpirationTime = try container.decodeIfPresent(.lastTrialPlanExpirationTime)
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: CodingKeys.self)

                            try container.encodeIfPresent(canSelectTrialPlan, forKey: .canSelectTrialPlan)
                            try container.encodeIfPresent(currentBillingPeriod, forKey: .currentBillingPeriod)
                            try container.encodeIfPresent(lastTrialPlanExpirationTime, forKey: .lastTrialPlanExpirationTime)
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? BuildService else { return false }
                          guard self.canSelectTrialPlan == object.canSelectTrialPlan else { return false }
                          guard self.currentBillingPeriod == object.currentBillingPeriod else { return false }
                          guard self.lastTrialPlanExpirationTime == object.lastTrialPlanExpirationTime else { return false }
                          return true
                        }

                        public static func == (lhs: BuildService, rhs: BuildService) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** Aggregated Billing Information for a given Organization. */
                    public class TestService: APIModel {

                        /** Can customer select trial plan for that service (if it exists)? */
                        public var canSelectTrialPlan: Bool?

                        /** Billing plans for a given period */
                        public var currentBillingPeriod: CurrentBillingPeriod?

                        /** Expiration time of the last selected trial plan. Will be null if trial plan was not used. */
                        public var lastTrialPlanExpirationTime: String?

                        /** Aggregated Billing Information for a given Organization. */
                        public class CurrentBillingPeriod: APIModel {

                            /** Selection of a billing plan */
                            public var byAccount: ByAccount?

                            /** Exclusive end of the period. */
                            public var endTime: String?

                            /** Inclusive start of the period */
                            public var startTime: String?

                            /** Aggregated Billing Information for a given Organization. */
                            public class ByAccount: APIModel {

                                /** Number of instances of the billing plan. */
                                public var count: Int?

                                /** Billing Plan */
                                public var plan: Plan?

                                /** Aggregated Billing Information for a given Organization. */
                                public class Plan: APIModel {

                                    /** Service that receives payments for this billing plan. */
                                    public enum PaymentSource: String, Codable {
                                        case none = "None"
                                        case appCenter = "AppCenter"
                                        case gitHub = "GitHub"
                                        case xtc = "Xtc"

                                        public static let cases: [PaymentSource] = [
                                          .none,
                                          .appCenter,
                                          .gitHub,
                                          .xtc,
                                        ]
                                    }

                                    /** Name of the service that the plan applies to. */
                                    public enum Service: String, Codable {
                                        case build = "Build"
                                        case test = "Test"

                                        public static let cases: [Service] = [
                                          .build,
                                          .test,
                                        ]
                                    }

                                    /** Collection of attribute values. */
                                    public var attributes: [String: [String: Any]]?

                                    /** The Billing Plan ID */
                                    public var id: String?

                                    /** A collection of named numeric values */
                                    public var limits: [String: Double]?

                                    public var parentId: String?

                                    /** Service that receives payments for this billing plan. */
                                    public var paymentSource: PaymentSource?

                                    /** Price of the Billing Plan */
                                    public var price: Double?

                                    /** Name of the service that the plan applies to. */
                                    public var service: Service?

                                    /** Version of the Billing Plan schema */
                                    public var version: String?

                                    public init(attributes: [String: [String: Any]]? = nil, id: String? = nil, limits: [String: Double]? = nil, parentId: String? = nil, paymentSource: PaymentSource? = nil, price: Double? = nil, service: Service? = nil, version: String? = nil) {
                                        self.attributes = attributes
                                        self.id = id
                                        self.limits = limits
                                        self.parentId = parentId
                                        self.paymentSource = paymentSource
                                        self.price = price
                                        self.service = service
                                        self.version = version
                                    }

                                    private enum CodingKeys: String, CodingKey {
                                        case attributes
                                        case id
                                        case limits
                                        case parentId
                                        case paymentSource
                                        case price
                                        case service
                                        case version
                                    }

                                    public required init(from decoder: Decoder) throws {
                                        let container = try decoder.container(keyedBy: CodingKeys.self)

                                        attributes = try container.decodeAnyIfPresent(.attributes)
                                        id = try container.decodeIfPresent(.id)
                                        limits = try container.decodeIfPresent(.limits)
                                        parentId = try container.decodeIfPresent(.parentId)
                                        paymentSource = try container.decodeIfPresent(.paymentSource)
                                        price = try container.decodeIfPresent(.price)
                                        service = try container.decodeIfPresent(.service)
                                        version = try container.decodeIfPresent(.version)
                                    }

                                    public func encode(to encoder: Encoder) throws {
                                        var container = encoder.container(keyedBy: CodingKeys.self)

                                        try container.encodeAnyIfPresent(attributes, forKey: .attributes)
                                        try container.encodeIfPresent(id, forKey: .id)
                                        try container.encodeIfPresent(limits, forKey: .limits)
                                        try container.encodeIfPresent(parentId, forKey: .parentId)
                                        try container.encodeIfPresent(paymentSource, forKey: .paymentSource)
                                        try container.encodeIfPresent(price, forKey: .price)
                                        try container.encodeIfPresent(service, forKey: .service)
                                        try container.encodeIfPresent(version, forKey: .version)
                                    }

                                    public func isEqual(to object: Any?) -> Bool {
                                      guard let object = object as? Plan else { return false }
                                      guard self.attributes == object.attributes else { return false }
                                      guard self.id == object.id else { return false }
                                      guard self.limits == object.limits else { return false }
                                      guard self.parentId == object.parentId else { return false }
                                      guard self.paymentSource == object.paymentSource else { return false }
                                      guard self.price == object.price else { return false }
                                      guard self.service == object.service else { return false }
                                      guard self.version == object.version else { return false }
                                      return true
                                    }

                                    public static func == (lhs: Plan, rhs: Plan) -> Bool {
                                        return lhs.isEqual(to: rhs)
                                    }
                                }

                                public init(count: Int? = nil, plan: Plan? = nil) {
                                    self.count = count
                                    self.plan = plan
                                }

                                private enum CodingKeys: String, CodingKey {
                                    case count
                                    case plan
                                }

                                public required init(from decoder: Decoder) throws {
                                    let container = try decoder.container(keyedBy: CodingKeys.self)

                                    count = try container.decodeIfPresent(.count)
                                    plan = try container.decodeIfPresent(.plan)
                                }

                                public func encode(to encoder: Encoder) throws {
                                    var container = encoder.container(keyedBy: CodingKeys.self)

                                    try container.encodeIfPresent(count, forKey: .count)
                                    try container.encodeIfPresent(plan, forKey: .plan)
                                }

                                public func isEqual(to object: Any?) -> Bool {
                                  guard let object = object as? ByAccount else { return false }
                                  guard self.count == object.count else { return false }
                                  guard self.plan == object.plan else { return false }
                                  return true
                                }

                                public static func == (lhs: ByAccount, rhs: ByAccount) -> Bool {
                                    return lhs.isEqual(to: rhs)
                                }
                            }

                            public init(byAccount: ByAccount? = nil, endTime: String? = nil, startTime: String? = nil) {
                                self.byAccount = byAccount
                                self.endTime = endTime
                                self.startTime = startTime
                            }

                            private enum CodingKeys: String, CodingKey {
                                case byAccount
                                case endTime
                                case startTime
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: CodingKeys.self)

                                byAccount = try container.decodeIfPresent(.byAccount)
                                endTime = try container.decodeIfPresent(.endTime)
                                startTime = try container.decodeIfPresent(.startTime)
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: CodingKeys.self)

                                try container.encodeIfPresent(byAccount, forKey: .byAccount)
                                try container.encodeIfPresent(endTime, forKey: .endTime)
                                try container.encodeIfPresent(startTime, forKey: .startTime)
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? CurrentBillingPeriod else { return false }
                              guard self.byAccount == object.byAccount else { return false }
                              guard self.endTime == object.endTime else { return false }
                              guard self.startTime == object.startTime else { return false }
                              return true
                            }

                            public static func == (lhs: CurrentBillingPeriod, rhs: CurrentBillingPeriod) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(canSelectTrialPlan: Bool? = nil, currentBillingPeriod: CurrentBillingPeriod? = nil, lastTrialPlanExpirationTime: String? = nil) {
                            self.canSelectTrialPlan = canSelectTrialPlan
                            self.currentBillingPeriod = currentBillingPeriod
                            self.lastTrialPlanExpirationTime = lastTrialPlanExpirationTime
                        }

                        private enum CodingKeys: String, CodingKey {
                            case canSelectTrialPlan
                            case currentBillingPeriod
                            case lastTrialPlanExpirationTime
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: CodingKeys.self)

                            canSelectTrialPlan = try container.decodeIfPresent(.canSelectTrialPlan)
                            currentBillingPeriod = try container.decodeIfPresent(.currentBillingPeriod)
                            lastTrialPlanExpirationTime = try container.decodeIfPresent(.lastTrialPlanExpirationTime)
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: CodingKeys.self)

                            try container.encodeIfPresent(canSelectTrialPlan, forKey: .canSelectTrialPlan)
                            try container.encodeIfPresent(currentBillingPeriod, forKey: .currentBillingPeriod)
                            try container.encodeIfPresent(lastTrialPlanExpirationTime, forKey: .lastTrialPlanExpirationTime)
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? TestService else { return false }
                          guard self.canSelectTrialPlan == object.canSelectTrialPlan else { return false }
                          guard self.currentBillingPeriod == object.currentBillingPeriod else { return false }
                          guard self.lastTrialPlanExpirationTime == object.lastTrialPlanExpirationTime else { return false }
                          return true
                        }

                        public static func == (lhs: TestService, rhs: TestService) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                        self.buildService = buildService
                        self.testService = testService
                    }

                    private enum CodingKeys: String, CodingKey {
                        case buildService
                        case testService
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)

                        buildService = try container.decodeIfPresent(.buildService)
                        testService = try container.decodeIfPresent(.testService)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: CodingKeys.self)

                        try container.encodeIfPresent(buildService, forKey: .buildService)
                        try container.encodeIfPresent(testService, forKey: .testService)
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? BillingPlans else { return false }
                      guard self.buildService == object.buildService else { return false }
                      guard self.testService == object.testService else { return false }
                      return true
                    }

                    public static func == (lhs: BillingPlans, rhs: BillingPlans) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** Aggregated Billing Information for a given Organization. */
                public class Usage: APIModel {

                    /** Resource usage for a single Mobile Center service */
                    public var buildService: BuildService?

                    /** Resource usage for a single Mobile Center service */
                    public var testService: TestService?

                    /** Aggregated Billing Information for a given Organization. */
                    public class BuildService: APIModel {

                        /** Usage for a single period */
                        public var currentUsagePeriod: CurrentUsagePeriod?

                        /** Aggregated Billing Information for a given Organization. */
                        public class CurrentUsagePeriod: APIModel {

                            /** A collection of named numeric values */
                            public var byAccount: [String: Double]?

                            /** A collection of  named numeric values grouped by app */
                            public var byApp: [String: [String: Double]]?

                            /** Exclusive end time of the usage period. */
                            public var endTime: String?

                            /** Inclusive start time of the usage period */
                            public var startTime: String?

                            public init(byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil, endTime: String? = nil, startTime: String? = nil) {
                                self.byAccount = byAccount
                                self.byApp = byApp
                                self.endTime = endTime
                                self.startTime = startTime
                            }

                            private enum CodingKeys: String, CodingKey {
                                case byAccount
                                case byApp
                                case endTime
                                case startTime
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: CodingKeys.self)

                                byAccount = try container.decodeIfPresent(.byAccount)
                                byApp = try container.decodeIfPresent(.byApp)
                                endTime = try container.decodeIfPresent(.endTime)
                                startTime = try container.decodeIfPresent(.startTime)
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: CodingKeys.self)

                                try container.encodeIfPresent(byAccount, forKey: .byAccount)
                                try container.encodeIfPresent(byApp, forKey: .byApp)
                                try container.encodeIfPresent(endTime, forKey: .endTime)
                                try container.encodeIfPresent(startTime, forKey: .startTime)
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? CurrentUsagePeriod else { return false }
                              guard self.byAccount == object.byAccount else { return false }
                              guard self.byApp == object.byApp else { return false }
                              guard self.endTime == object.endTime else { return false }
                              guard self.startTime == object.startTime else { return false }
                              return true
                            }

                            public static func == (lhs: CurrentUsagePeriod, rhs: CurrentUsagePeriod) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                            self.currentUsagePeriod = currentUsagePeriod
                        }

                        private enum CodingKeys: String, CodingKey {
                            case currentUsagePeriod
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: CodingKeys.self)

                            currentUsagePeriod = try container.decodeIfPresent(.currentUsagePeriod)
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: CodingKeys.self)

                            try container.encodeIfPresent(currentUsagePeriod, forKey: .currentUsagePeriod)
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? BuildService else { return false }
                          guard self.currentUsagePeriod == object.currentUsagePeriod else { return false }
                          return true
                        }

                        public static func == (lhs: BuildService, rhs: BuildService) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** Aggregated Billing Information for a given Organization. */
                    public class TestService: APIModel {

                        /** Usage for a single period */
                        public var currentUsagePeriod: CurrentUsagePeriod?

                        /** Aggregated Billing Information for a given Organization. */
                        public class CurrentUsagePeriod: APIModel {

                            /** A collection of named numeric values */
                            public var byAccount: [String: Double]?

                            /** A collection of  named numeric values grouped by app */
                            public var byApp: [String: [String: Double]]?

                            /** Exclusive end time of the usage period. */
                            public var endTime: String?

                            /** Inclusive start time of the usage period */
                            public var startTime: String?

                            public init(byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil, endTime: String? = nil, startTime: String? = nil) {
                                self.byAccount = byAccount
                                self.byApp = byApp
                                self.endTime = endTime
                                self.startTime = startTime
                            }

                            private enum CodingKeys: String, CodingKey {
                                case byAccount
                                case byApp
                                case endTime
                                case startTime
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: CodingKeys.self)

                                byAccount = try container.decodeIfPresent(.byAccount)
                                byApp = try container.decodeIfPresent(.byApp)
                                endTime = try container.decodeIfPresent(.endTime)
                                startTime = try container.decodeIfPresent(.startTime)
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: CodingKeys.self)

                                try container.encodeIfPresent(byAccount, forKey: .byAccount)
                                try container.encodeIfPresent(byApp, forKey: .byApp)
                                try container.encodeIfPresent(endTime, forKey: .endTime)
                                try container.encodeIfPresent(startTime, forKey: .startTime)
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? CurrentUsagePeriod else { return false }
                              guard self.byAccount == object.byAccount else { return false }
                              guard self.byApp == object.byApp else { return false }
                              guard self.endTime == object.endTime else { return false }
                              guard self.startTime == object.startTime else { return false }
                              return true
                            }

                            public static func == (lhs: CurrentUsagePeriod, rhs: CurrentUsagePeriod) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
                            self.currentUsagePeriod = currentUsagePeriod
                        }

                        private enum CodingKeys: String, CodingKey {
                            case currentUsagePeriod
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: CodingKeys.self)

                            currentUsagePeriod = try container.decodeIfPresent(.currentUsagePeriod)
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: CodingKeys.self)

                            try container.encodeIfPresent(currentUsagePeriod, forKey: .currentUsagePeriod)
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? TestService else { return false }
                          guard self.currentUsagePeriod == object.currentUsagePeriod else { return false }
                          return true
                        }

                        public static func == (lhs: TestService, rhs: TestService) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
                        self.buildService = buildService
                        self.testService = testService
                    }

                    private enum CodingKeys: String, CodingKey {
                        case buildService
                        case testService
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)

                        buildService = try container.decodeIfPresent(.buildService)
                        testService = try container.decodeIfPresent(.testService)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: CodingKeys.self)

                        try container.encodeIfPresent(buildService, forKey: .buildService)
                        try container.encodeIfPresent(testService, forKey: .testService)
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Usage else { return false }
                      guard self.buildService == object.buildService else { return false }
                      guard self.testService == object.testService else { return false }
                      return true
                    }

                    public static func == (lhs: Usage, rhs: Usage) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(azureSubscriptionId: String? = nil, azureSubscriptionState: AzureSubscriptionState? = nil, billingPlans: BillingPlans? = nil, id: String? = nil, timestamp: String? = nil, usage: Usage? = nil, version: String? = nil) {
                    self.azureSubscriptionId = azureSubscriptionId
                    self.azureSubscriptionState = azureSubscriptionState
                    self.billingPlans = billingPlans
                    self.id = id
                    self.timestamp = timestamp
                    self.usage = usage
                    self.version = version
                }

                private enum CodingKeys: String, CodingKey {
                    case azureSubscriptionId
                    case azureSubscriptionState
                    case billingPlans
                    case id
                    case timestamp
                    case usage
                    case version
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    azureSubscriptionId = try container.decodeIfPresent(.azureSubscriptionId)
                    azureSubscriptionState = try container.decodeIfPresent(.azureSubscriptionState)
                    billingPlans = try container.decodeIfPresent(.billingPlans)
                    id = try container.decodeIfPresent(.id)
                    timestamp = try container.decodeIfPresent(.timestamp)
                    usage = try container.decodeIfPresent(.usage)
                    version = try container.decodeIfPresent(.version)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(azureSubscriptionId, forKey: .azureSubscriptionId)
                    try container.encodeIfPresent(azureSubscriptionState, forKey: .azureSubscriptionState)
                    try container.encodeIfPresent(billingPlans, forKey: .billingPlans)
                    try container.encodeIfPresent(id, forKey: .id)
                    try container.encodeIfPresent(timestamp, forKey: .timestamp)
                    try container.encodeIfPresent(usage, forKey: .usage)
                    try container.encodeIfPresent(version, forKey: .version)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.azureSubscriptionId == object.azureSubscriptionId else { return false }
                  guard self.azureSubscriptionState == object.azureSubscriptionState else { return false }
                  guard self.billingPlans == object.billingPlans else { return false }
                  guard self.id == object.id else { return false }
                  guard self.timestamp == object.timestamp else { return false }
                  guard self.usage == object.usage else { return false }
                  guard self.version == object.version else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Aggregated Billing Information for a given Organization. */
            public class DefaultResponse: APIModel {

                public var error: ErrorType?

                /** Aggregated Billing Information for a given Organization. */
                public class ErrorType: APIModel {

                    /** The status code return by the API. It can be 400 or 403 or 500. */
                    public enum Code: Int, Codable {
                        case _400 = 400
                        case _403 = 403
                        case _500 = 500

                        public static let cases: [Code] = [
                          ._400,
                          ._403,
                          ._500,
                        ]
                    }

                    /** The status code return by the API. It can be 400 or 403 or 500. */
                    public var code: Code?

                    /** The reason for the request failed */
                    public var message: String?

                    public init(code: Code? = nil, message: String? = nil) {
                        self.code = code
                        self.message = message
                    }

                    private enum CodingKeys: String, CodingKey {
                        case code
                        case message
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)

                        code = try container.decodeIfPresent(.code)
                        message = try container.decodeIfPresent(.message)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: CodingKeys.self)

                        try container.encodeIfPresent(code, forKey: .code)
                        try container.encodeIfPresent(message, forKey: .message)
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? ErrorType else { return false }
                      guard self.code == object.code else { return false }
                      guard self.message == object.message else { return false }
                      return true
                    }

                    public static func == (lhs: ErrorType, rhs: ErrorType) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(error: ErrorType? = nil) {
                    self.error = error
                }

                private enum CodingKeys: String, CodingKey {
                    case error
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    error = try container.decodeIfPresent(.error)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(error, forKey: .error)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? DefaultResponse else { return false }
                  guard self.error == object.error else { return false }
                  return true
                }

                public static func == (lhs: DefaultResponse, rhs: DefaultResponse) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200

            /** Aggregated Billing Information for a given Organization */
            case status200(Status200)

            /** Error code with reason */
            case defaultResponse(statusCode: Int, DefaultResponse)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var failure: DefaultResponse? {
                switch self {
                case .defaultResponse(_, let response): return response
                default: return nil
                }
            }

            /// either success or failure value. Success is anything in the 200..<300 status code range
            public var responseResult: APIResponseResult<Status200, DefaultResponse> {
                if let successValue = success {
                    return .success(successValue)
                } else if let failureValue = failure {
                    return .failure(failureValue)
                } else {
                    fatalError("Response does not have success or failure response")
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .defaultResponse(_, let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .defaultResponse(let statusCode, _): return statusCode
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .defaultResponse: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: self = try .defaultResponse(statusCode: statusCode, decoder.decode(DefaultResponse.self, from: data))
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
