//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Report data for a single test (a.k.a. scenario) */
public class PerformanceReport: APIModel {

    public var deviceSnapshotId: String?

    public var performanceData: PerformanceData?

    public var video: Video?

    /** Report data for a single test (a.k.a. scenario) */
    public class PerformanceData: APIModel {

        public var steps: [Steps]

        public var elapsedSecsEnd: Double

        public var elapsedSecsStart: Double

        public var elapsedSecs: Double

        public var id: String

        public init(steps: [Steps], elapsedSecsEnd: Double, elapsedSecsStart: Double, elapsedSecs: Double, id: String) {
            self.steps = steps
            self.elapsedSecsEnd = elapsedSecsEnd
            self.elapsedSecsStart = elapsedSecsStart
            self.elapsedSecs = elapsedSecs
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case steps
            case elapsedSecsEnd = "elapsed-secs-end"
            case elapsedSecsStart = "elapsed-secs-start"
            case elapsedSecs = "elapsed-secs"
            case id
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            steps = try container.decodeArray(.steps)
            elapsedSecsEnd = try container.decode(.elapsedSecsEnd)
            elapsedSecsStart = try container.decode(.elapsedSecsStart)
            elapsedSecs = try container.decode(.elapsedSecs)
            id = try container.decode(.id)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(steps, forKey: .steps)
            try container.encode(elapsedSecsEnd, forKey: .elapsedSecsEnd)
            try container.encode(elapsedSecsStart, forKey: .elapsedSecsStart)
            try container.encode(elapsedSecs, forKey: .elapsedSecs)
            try container.encode(id, forKey: .id)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? PerformanceData else { return false }
          guard self.steps == object.steps else { return false }
          guard self.elapsedSecsEnd == object.elapsedSecsEnd else { return false }
          guard self.elapsedSecsStart == object.elapsedSecsStart else { return false }
          guard self.elapsedSecs == object.elapsedSecs else { return false }
          guard self.id == object.id else { return false }
          return true
        }

        public static func == (lhs: PerformanceData, rhs: PerformanceData) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** Report data for a single test (a.k.a. scenario) */
    public class Video: APIModel {

        public var videoMetadata: VideoMetadata

        public var videoURL: String

        /** Report data for a single test (a.k.a. scenario) */
        public class VideoMetadata: APIModel {

            public var events: [Events]?

            public init(events: [Events]? = nil) {
                self.events = events
            }

            private enum CodingKeys: String, CodingKey {
                case events
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                events = try container.decodeArrayIfPresent(.events)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(events, forKey: .events)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? VideoMetadata else { return false }
              guard self.events == object.events else { return false }
              return true
            }

            public static func == (lhs: VideoMetadata, rhs: VideoMetadata) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(videoMetadata: VideoMetadata, videoURL: String) {
            self.videoMetadata = videoMetadata
            self.videoURL = videoURL
        }

        private enum CodingKeys: String, CodingKey {
            case videoMetadata = "video_metadata"
            case videoURL = "video_url"
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            videoMetadata = try container.decode(.videoMetadata)
            videoURL = try container.decode(.videoURL)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(videoMetadata, forKey: .videoMetadata)
            try container.encode(videoURL, forKey: .videoURL)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Video else { return false }
          guard self.videoMetadata == object.videoMetadata else { return false }
          guard self.videoURL == object.videoURL else { return false }
          return true
        }

        public static func == (lhs: Video, rhs: Video) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(deviceSnapshotId: String? = nil, performanceData: PerformanceData? = nil, video: Video? = nil) {
        self.deviceSnapshotId = deviceSnapshotId
        self.performanceData = performanceData
        self.video = video
    }

    private enum CodingKeys: String, CodingKey {
        case deviceSnapshotId = "device_snapshot_id"
        case performanceData = "performance_data"
        case video
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        deviceSnapshotId = try container.decodeIfPresent(.deviceSnapshotId)
        performanceData = try container.decodeIfPresent(.performanceData)
        video = try container.decodeIfPresent(.video)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(deviceSnapshotId, forKey: .deviceSnapshotId)
        try container.encodeIfPresent(performanceData, forKey: .performanceData)
        try container.encodeIfPresent(video, forKey: .video)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? PerformanceReport else { return false }
      guard self.deviceSnapshotId == object.deviceSnapshotId else { return false }
      guard self.performanceData == object.performanceData else { return false }
      guard self.video == object.video else { return false }
      return true
    }

    public static func == (lhs: PerformanceReport, rhs: PerformanceReport) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
