//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class MetricsResponse: APIModel {

    public enum DatabaseLocation: String, Codable {
        case eastAsia = "East Asia"
        case southeastAsia = "Southeast Asia"
        case australiaCentral = "Australia Central"
        case australiaCentral2 = "Australia Central 2"
        case australiaEast = "Australia East"
        case australiaSoutheast = "Australia Southeast"
        case brazilSouth = "Brazil South"
        case canadaCentral = "Canada Central"
        case canadaEast = "Canada East"
        case centralIndia = "Central India"
        case southIndia = "South India"
        case westIndia = "West India"
        case northEurope = "North Europe"
        case westEurope = "West Europe"
        case franceCentral = "France Central"
        case franceSouth = "France South"
        case germanyCentral = "Germany Central"
        case germanyNortheast = "Germany Northeast"
        case japanEast = "Japan East"
        case japanWest = "Japan West"
        case koreaCentral = "Korea Central"
        case koreaSouth = "Korea South"
        case southAfricaNorth = "South Africa North"
        case southAfricaWest = "South Africa West"
        case uKSouth = "UK South"
        case uKWest = "UK West"
        case centralUS = "Central US"
        case eastUS = "East US"
        case eastUS2 = "East US 2"
        case uSGovArizona = "US Gov Arizona"
        case uSGovTexas = "US Gov Texas"
        case northCentralUS = "North Central US"
        case southCentralUS = "South Central US"
        case westUS = "West US"
        case westUS2 = "West US 2"
        case westCentralUS = "West Central US"

        public static let cases: [DatabaseLocation] = [
          .eastAsia,
          .southeastAsia,
          .australiaCentral,
          .australiaCentral2,
          .australiaEast,
          .australiaSoutheast,
          .brazilSouth,
          .canadaCentral,
          .canadaEast,
          .centralIndia,
          .southIndia,
          .westIndia,
          .northEurope,
          .westEurope,
          .franceCentral,
          .franceSouth,
          .germanyCentral,
          .germanyNortheast,
          .japanEast,
          .japanWest,
          .koreaCentral,
          .koreaSouth,
          .southAfricaNorth,
          .southAfricaWest,
          .uKSouth,
          .uKWest,
          .centralUS,
          .eastUS,
          .eastUS2,
          .uSGovArizona,
          .uSGovTexas,
          .northCentralUS,
          .southCentralUS,
          .westUS,
          .westUS2,
          .westCentralUS,
        ]
    }

    public var accountName: String?

    public var databaseId: String?

    public var databaseLocation: DatabaseLocation?

    /** Represents database usage metrics. */
    public var metrics: Metrics?

    public class Metrics: APIModel {

        public var dataUsage: Double?

        public var indexUsage: Double?

        public var interval: Int?

        public var latencyMetrics: LatencyMetrics?

        public var totalRequestUnits: Double?

        public var totalRequests: Double?

        public class LatencyMetrics: APIModel {

            public var readLatencyMetrics: ReadLatencyMetrics?

            public var writeLatencyMetrics: WriteLatencyMetrics?

            public class ReadLatencyMetrics: APIModel {

                public var endTime: DateTime?

                public var metricValues: [MetricValues]?

                public var name: String?

                public var startTime: DateTime?

                public var unit: String?

                public init(endTime: DateTime? = nil, metricValues: [MetricValues]? = nil, name: String? = nil, startTime: DateTime? = nil, unit: String? = nil) {
                    self.endTime = endTime
                    self.metricValues = metricValues
                    self.name = name
                    self.startTime = startTime
                    self.unit = unit
                }

                private enum CodingKeys: String, CodingKey {
                    case endTime
                    case metricValues
                    case name
                    case startTime
                    case unit
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    endTime = try container.decodeIfPresent(.endTime)
                    metricValues = try container.decodeArrayIfPresent(.metricValues)
                    name = try container.decodeIfPresent(.name)
                    startTime = try container.decodeIfPresent(.startTime)
                    unit = try container.decodeIfPresent(.unit)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(endTime, forKey: .endTime)
                    try container.encodeIfPresent(metricValues, forKey: .metricValues)
                    try container.encodeIfPresent(name, forKey: .name)
                    try container.encodeIfPresent(startTime, forKey: .startTime)
                    try container.encodeIfPresent(unit, forKey: .unit)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? ReadLatencyMetrics else { return false }
                  guard self.endTime == object.endTime else { return false }
                  guard self.metricValues == object.metricValues else { return false }
                  guard self.name == object.name else { return false }
                  guard self.startTime == object.startTime else { return false }
                  guard self.unit == object.unit else { return false }
                  return true
                }

                public static func == (lhs: ReadLatencyMetrics, rhs: ReadLatencyMetrics) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public class WriteLatencyMetrics: APIModel {

                public var endTime: DateTime?

                public var metricValues: [MetricValues]?

                public var name: String?

                public var startTime: DateTime?

                public var unit: String?

                public init(endTime: DateTime? = nil, metricValues: [MetricValues]? = nil, name: String? = nil, startTime: DateTime? = nil, unit: String? = nil) {
                    self.endTime = endTime
                    self.metricValues = metricValues
                    self.name = name
                    self.startTime = startTime
                    self.unit = unit
                }

                private enum CodingKeys: String, CodingKey {
                    case endTime
                    case metricValues
                    case name
                    case startTime
                    case unit
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    endTime = try container.decodeIfPresent(.endTime)
                    metricValues = try container.decodeArrayIfPresent(.metricValues)
                    name = try container.decodeIfPresent(.name)
                    startTime = try container.decodeIfPresent(.startTime)
                    unit = try container.decodeIfPresent(.unit)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(endTime, forKey: .endTime)
                    try container.encodeIfPresent(metricValues, forKey: .metricValues)
                    try container.encodeIfPresent(name, forKey: .name)
                    try container.encodeIfPresent(startTime, forKey: .startTime)
                    try container.encodeIfPresent(unit, forKey: .unit)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? WriteLatencyMetrics else { return false }
                  guard self.endTime == object.endTime else { return false }
                  guard self.metricValues == object.metricValues else { return false }
                  guard self.name == object.name else { return false }
                  guard self.startTime == object.startTime else { return false }
                  guard self.unit == object.unit else { return false }
                  return true
                }

                public static func == (lhs: WriteLatencyMetrics, rhs: WriteLatencyMetrics) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public init(readLatencyMetrics: ReadLatencyMetrics? = nil, writeLatencyMetrics: WriteLatencyMetrics? = nil) {
                self.readLatencyMetrics = readLatencyMetrics
                self.writeLatencyMetrics = writeLatencyMetrics
            }

            private enum CodingKeys: String, CodingKey {
                case readLatencyMetrics
                case writeLatencyMetrics
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                readLatencyMetrics = try container.decodeIfPresent(.readLatencyMetrics)
                writeLatencyMetrics = try container.decodeIfPresent(.writeLatencyMetrics)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(readLatencyMetrics, forKey: .readLatencyMetrics)
                try container.encodeIfPresent(writeLatencyMetrics, forKey: .writeLatencyMetrics)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? LatencyMetrics else { return false }
              guard self.readLatencyMetrics == object.readLatencyMetrics else { return false }
              guard self.writeLatencyMetrics == object.writeLatencyMetrics else { return false }
              return true
            }

            public static func == (lhs: LatencyMetrics, rhs: LatencyMetrics) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(dataUsage: Double? = nil, indexUsage: Double? = nil, interval: Int? = nil, latencyMetrics: LatencyMetrics? = nil, totalRequestUnits: Double? = nil, totalRequests: Double? = nil) {
            self.dataUsage = dataUsage
            self.indexUsage = indexUsage
            self.interval = interval
            self.latencyMetrics = latencyMetrics
            self.totalRequestUnits = totalRequestUnits
            self.totalRequests = totalRequests
        }

        private enum CodingKeys: String, CodingKey {
            case dataUsage
            case indexUsage
            case interval
            case latencyMetrics
            case totalRequestUnits
            case totalRequests
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            dataUsage = try container.decodeIfPresent(.dataUsage)
            indexUsage = try container.decodeIfPresent(.indexUsage)
            interval = try container.decodeIfPresent(.interval)
            latencyMetrics = try container.decodeIfPresent(.latencyMetrics)
            totalRequestUnits = try container.decodeIfPresent(.totalRequestUnits)
            totalRequests = try container.decodeIfPresent(.totalRequests)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(dataUsage, forKey: .dataUsage)
            try container.encodeIfPresent(indexUsage, forKey: .indexUsage)
            try container.encodeIfPresent(interval, forKey: .interval)
            try container.encodeIfPresent(latencyMetrics, forKey: .latencyMetrics)
            try container.encodeIfPresent(totalRequestUnits, forKey: .totalRequestUnits)
            try container.encodeIfPresent(totalRequests, forKey: .totalRequests)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Metrics else { return false }
          guard self.dataUsage == object.dataUsage else { return false }
          guard self.indexUsage == object.indexUsage else { return false }
          guard self.interval == object.interval else { return false }
          guard self.latencyMetrics == object.latencyMetrics else { return false }
          guard self.totalRequestUnits == object.totalRequestUnits else { return false }
          guard self.totalRequests == object.totalRequests else { return false }
          return true
        }

        public static func == (lhs: Metrics, rhs: Metrics) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(accountName: String? = nil, databaseId: String? = nil, databaseLocation: DatabaseLocation? = nil, metrics: Metrics? = nil) {
        self.accountName = accountName
        self.databaseId = databaseId
        self.databaseLocation = databaseLocation
        self.metrics = metrics
    }

    private enum CodingKeys: String, CodingKey {
        case accountName
        case databaseId
        case databaseLocation
        case metrics
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accountName = try container.decodeIfPresent(.accountName)
        databaseId = try container.decodeIfPresent(.databaseId)
        databaseLocation = try container.decodeIfPresent(.databaseLocation)
        metrics = try container.decodeIfPresent(.metrics)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(accountName, forKey: .accountName)
        try container.encodeIfPresent(databaseId, forKey: .databaseId)
        try container.encodeIfPresent(databaseLocation, forKey: .databaseLocation)
        try container.encodeIfPresent(metrics, forKey: .metrics)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? MetricsResponse else { return false }
      guard self.accountName == object.accountName else { return false }
      guard self.databaseId == object.databaseId else { return false }
      guard self.databaseLocation == object.databaseLocation else { return false }
      guard self.metrics == object.metrics else { return false }
      return true
    }

    public static func == (lhs: MetricsResponse, rhs: MetricsResponse) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
