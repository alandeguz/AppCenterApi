//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Summary single test run on Xamarin Test Cloud */
public class TestRunStatistics: APIModel {

    /** Number of devices running the test */
    public var devices: Double?

    /** Number of failed devices */
    public var devicesFailed: Double?

    /** Number of finished devices */
    public var devicesFinished: Double?

    /** Number of failed tests */
    public var failed: Double?

    /** Number of passed tests */
    public var passed: Double?

    /** The max amount of MB used during the test run */
    public var peakMemory: Double?

    /** Number of skipped tests */
    public var skipped: Double?

    /** Number of tests in total */
    public var total: Double?

    /** The number of minutes of device time the test has been runnign */
    public var totalDeviceMinutes: Double?

    public init(devices: Double? = nil, devicesFailed: Double? = nil, devicesFinished: Double? = nil, failed: Double? = nil, passed: Double? = nil, peakMemory: Double? = nil, skipped: Double? = nil, total: Double? = nil, totalDeviceMinutes: Double? = nil) {
        self.devices = devices
        self.devicesFailed = devicesFailed
        self.devicesFinished = devicesFinished
        self.failed = failed
        self.passed = passed
        self.peakMemory = peakMemory
        self.skipped = skipped
        self.total = total
        self.totalDeviceMinutes = totalDeviceMinutes
    }

    private enum CodingKeys: String, CodingKey {
        case devices
        case devicesFailed
        case devicesFinished
        case failed
        case passed
        case peakMemory
        case skipped
        case total
        case totalDeviceMinutes
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        devices = try container.decodeIfPresent(.devices)
        devicesFailed = try container.decodeIfPresent(.devicesFailed)
        devicesFinished = try container.decodeIfPresent(.devicesFinished)
        failed = try container.decodeIfPresent(.failed)
        passed = try container.decodeIfPresent(.passed)
        peakMemory = try container.decodeIfPresent(.peakMemory)
        skipped = try container.decodeIfPresent(.skipped)
        total = try container.decodeIfPresent(.total)
        totalDeviceMinutes = try container.decodeIfPresent(.totalDeviceMinutes)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(devices, forKey: .devices)
        try container.encodeIfPresent(devicesFailed, forKey: .devicesFailed)
        try container.encodeIfPresent(devicesFinished, forKey: .devicesFinished)
        try container.encodeIfPresent(failed, forKey: .failed)
        try container.encodeIfPresent(passed, forKey: .passed)
        try container.encodeIfPresent(peakMemory, forKey: .peakMemory)
        try container.encodeIfPresent(skipped, forKey: .skipped)
        try container.encodeIfPresent(total, forKey: .total)
        try container.encodeIfPresent(totalDeviceMinutes, forKey: .totalDeviceMinutes)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? TestRunStatistics else { return false }
      guard self.devices == object.devices else { return false }
      guard self.devicesFailed == object.devicesFailed else { return false }
      guard self.devicesFinished == object.devicesFinished else { return false }
      guard self.failed == object.failed else { return false }
      guard self.passed == object.passed else { return false }
      guard self.peakMemory == object.peakMemory else { return false }
      guard self.skipped == object.skipped else { return false }
      guard self.total == object.total else { return false }
      guard self.totalDeviceMinutes == object.totalDeviceMinutes else { return false }
      return true
    }

    public static func == (lhs: TestRunStatistics, rhs: TestRunStatistics) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
