//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class Event: APIModel {

    public var count: Int?

    public var countPerDevice: Double?

    public var countPerSession: Double?

    public var deviceCount: Int?

    public var id: String?

    public var name: String?

    /** The event count of previous time range of the event. */
    public var previousCount: Int?

    /** The device count of previous time range of the event. */
    public var previousDeviceCount: Int?

    public init(count: Int? = nil, countPerDevice: Double? = nil, countPerSession: Double? = nil, deviceCount: Int? = nil, id: String? = nil, name: String? = nil, previousCount: Int? = nil, previousDeviceCount: Int? = nil) {
        self.count = count
        self.countPerDevice = countPerDevice
        self.countPerSession = countPerSession
        self.deviceCount = deviceCount
        self.id = id
        self.name = name
        self.previousCount = previousCount
        self.previousDeviceCount = previousDeviceCount
    }

    private enum CodingKeys: String, CodingKey {
        case count
        case countPerDevice = "count_per_device"
        case countPerSession = "count_per_session"
        case deviceCount = "device_count"
        case id
        case name
        case previousCount = "previous_count"
        case previousDeviceCount = "previous_device_count"
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        count = try container.decodeIfPresent(.count)
        countPerDevice = try container.decodeIfPresent(.countPerDevice)
        countPerSession = try container.decodeIfPresent(.countPerSession)
        deviceCount = try container.decodeIfPresent(.deviceCount)
        id = try container.decodeIfPresent(.id)
        name = try container.decodeIfPresent(.name)
        previousCount = try container.decodeIfPresent(.previousCount)
        previousDeviceCount = try container.decodeIfPresent(.previousDeviceCount)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(count, forKey: .count)
        try container.encodeIfPresent(countPerDevice, forKey: .countPerDevice)
        try container.encodeIfPresent(countPerSession, forKey: .countPerSession)
        try container.encodeIfPresent(deviceCount, forKey: .deviceCount)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(previousCount, forKey: .previousCount)
        try container.encodeIfPresent(previousDeviceCount, forKey: .previousDeviceCount)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? Event else { return false }
      guard self.count == object.count else { return false }
      guard self.countPerDevice == object.countPerDevice else { return false }
      guard self.countPerSession == object.countPerSession else { return false }
      guard self.deviceCount == object.deviceCount else { return false }
      guard self.id == object.id else { return false }
      guard self.name == object.name else { return false }
      guard self.previousCount == object.previousCount else { return false }
      guard self.previousDeviceCount == object.previousDeviceCount else { return false }
      return true
    }

    public static func == (lhs: Event, rhs: Event) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
