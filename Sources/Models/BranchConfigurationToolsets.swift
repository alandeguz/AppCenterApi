//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** The branch build configuration for each toolset */
public class BranchConfigurationToolsets: APIModel {

    /** Build configuration for Android projects */
    public var android: Android?

    /** Build configuration when React Native, or other JavaScript tech, is part of the build steps */
    public var javascript: Javascript?

    /** Build configuration for Xamarin projects */
    public var xamarin: Xamarin?

    /** Build configuration when Xcode is part of the build steps */
    public var xcode: Xcode?

    /** The branch build configuration for each toolset */
    public class Android: APIModel {

        /** Whether to apply automatic signing or not */
        public var automaticSigning: Bool?

        /** The Android build variant to build */
        public var buildVariant: String?

        /** Path to the Gradle wrapper script */
        public var gradleWrapperPath: String?

        /** Whether it is the root module or not */
        public var isRoot: Bool?

        /** The key alias */
        public var keyAlias: String?

        /** The key password */
        public var keyPassword: String?

        /** The keystore encoded value */
        public var keystoreEncoded: String?

        /** The name of the keystore file */
        public var keystoreFilename: String?

        /** The password of the keystore */
        public var keystorePassword: String?

        /** The Gradle module to build */
        public var module: String?

        /** Whether to run lint checks during the build (default) */
        public var runLint: Bool?

        /** Whether to run unit tests during the build (default) */
        public var runTests: Bool?

        public init(automaticSigning: Bool? = nil, buildVariant: String? = nil, gradleWrapperPath: String? = nil, isRoot: Bool? = nil, keyAlias: String? = nil, keyPassword: String? = nil, keystoreEncoded: String? = nil, keystoreFilename: String? = nil, keystorePassword: String? = nil, module: String? = nil, runLint: Bool? = nil, runTests: Bool? = nil) {
            self.automaticSigning = automaticSigning
            self.buildVariant = buildVariant
            self.gradleWrapperPath = gradleWrapperPath
            self.isRoot = isRoot
            self.keyAlias = keyAlias
            self.keyPassword = keyPassword
            self.keystoreEncoded = keystoreEncoded
            self.keystoreFilename = keystoreFilename
            self.keystorePassword = keystorePassword
            self.module = module
            self.runLint = runLint
            self.runTests = runTests
        }

        private enum CodingKeys: String, CodingKey {
            case automaticSigning
            case buildVariant
            case gradleWrapperPath
            case isRoot
            case keyAlias
            case keyPassword
            case keystoreEncoded
            case keystoreFilename
            case keystorePassword
            case module
            case runLint
            case runTests
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            automaticSigning = try container.decodeIfPresent(.automaticSigning)
            buildVariant = try container.decodeIfPresent(.buildVariant)
            gradleWrapperPath = try container.decodeIfPresent(.gradleWrapperPath)
            isRoot = try container.decodeIfPresent(.isRoot)
            keyAlias = try container.decodeIfPresent(.keyAlias)
            keyPassword = try container.decodeIfPresent(.keyPassword)
            keystoreEncoded = try container.decodeIfPresent(.keystoreEncoded)
            keystoreFilename = try container.decodeIfPresent(.keystoreFilename)
            keystorePassword = try container.decodeIfPresent(.keystorePassword)
            module = try container.decodeIfPresent(.module)
            runLint = try container.decodeIfPresent(.runLint)
            runTests = try container.decodeIfPresent(.runTests)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(automaticSigning, forKey: .automaticSigning)
            try container.encodeIfPresent(buildVariant, forKey: .buildVariant)
            try container.encodeIfPresent(gradleWrapperPath, forKey: .gradleWrapperPath)
            try container.encodeIfPresent(isRoot, forKey: .isRoot)
            try container.encodeIfPresent(keyAlias, forKey: .keyAlias)
            try container.encodeIfPresent(keyPassword, forKey: .keyPassword)
            try container.encodeIfPresent(keystoreEncoded, forKey: .keystoreEncoded)
            try container.encodeIfPresent(keystoreFilename, forKey: .keystoreFilename)
            try container.encodeIfPresent(keystorePassword, forKey: .keystorePassword)
            try container.encodeIfPresent(module, forKey: .module)
            try container.encodeIfPresent(runLint, forKey: .runLint)
            try container.encodeIfPresent(runTests, forKey: .runTests)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Android else { return false }
          guard self.automaticSigning == object.automaticSigning else { return false }
          guard self.buildVariant == object.buildVariant else { return false }
          guard self.gradleWrapperPath == object.gradleWrapperPath else { return false }
          guard self.isRoot == object.isRoot else { return false }
          guard self.keyAlias == object.keyAlias else { return false }
          guard self.keyPassword == object.keyPassword else { return false }
          guard self.keystoreEncoded == object.keystoreEncoded else { return false }
          guard self.keystoreFilename == object.keystoreFilename else { return false }
          guard self.keystorePassword == object.keystorePassword else { return false }
          guard self.module == object.module else { return false }
          guard self.runLint == object.runLint else { return false }
          guard self.runTests == object.runTests else { return false }
          return true
        }

        public static func == (lhs: Android, rhs: Android) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** The branch build configuration for each toolset */
    public class Javascript: APIModel {

        /** Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json" */
        public var packageJsonPath: String?

        /** Version of React Native from package.json files */
        public var reactNativeVersion: String?

        /** Whether to run Jest unit tests, via npm test, during the build */
        public var runTests: Bool?

        public init(packageJsonPath: String? = nil, reactNativeVersion: String? = nil, runTests: Bool? = nil) {
            self.packageJsonPath = packageJsonPath
            self.reactNativeVersion = reactNativeVersion
            self.runTests = runTests
        }

        private enum CodingKeys: String, CodingKey {
            case packageJsonPath
            case reactNativeVersion
            case runTests
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            packageJsonPath = try container.decodeIfPresent(.packageJsonPath)
            reactNativeVersion = try container.decodeIfPresent(.reactNativeVersion)
            runTests = try container.decodeIfPresent(.runTests)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(packageJsonPath, forKey: .packageJsonPath)
            try container.encodeIfPresent(reactNativeVersion, forKey: .reactNativeVersion)
            try container.encodeIfPresent(runTests, forKey: .runTests)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Javascript else { return false }
          guard self.packageJsonPath == object.packageJsonPath else { return false }
          guard self.reactNativeVersion == object.reactNativeVersion else { return false }
          guard self.runTests == object.runTests else { return false }
          return true
        }

        public static func == (lhs: Javascript, rhs: Javascript) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** The branch build configuration for each toolset */
    public class Xamarin: APIModel {

        public var args: String?

        public var configuration: String?

        public var isSimBuild: Bool?

        public var monoVersion: String?

        public var p12File: String?

        public var p12Pwd: String?

        public var provProfile: String?

        public var sdkBundle: String?

        public var slnPath: String?

        /** Symlink of the SDK Bundle and Mono installation.
    The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.
     */
        public var symlink: String?

        public init(args: String? = nil, configuration: String? = nil, isSimBuild: Bool? = nil, monoVersion: String? = nil, p12File: String? = nil, p12Pwd: String? = nil, provProfile: String? = nil, sdkBundle: String? = nil, slnPath: String? = nil, symlink: String? = nil) {
            self.args = args
            self.configuration = configuration
            self.isSimBuild = isSimBuild
            self.monoVersion = monoVersion
            self.p12File = p12File
            self.p12Pwd = p12Pwd
            self.provProfile = provProfile
            self.sdkBundle = sdkBundle
            self.slnPath = slnPath
            self.symlink = symlink
        }

        private enum CodingKeys: String, CodingKey {
            case args
            case configuration
            case isSimBuild
            case monoVersion
            case p12File
            case p12Pwd
            case provProfile
            case sdkBundle
            case slnPath
            case symlink
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            args = try container.decodeIfPresent(.args)
            configuration = try container.decodeIfPresent(.configuration)
            isSimBuild = try container.decodeIfPresent(.isSimBuild)
            monoVersion = try container.decodeIfPresent(.monoVersion)
            p12File = try container.decodeIfPresent(.p12File)
            p12Pwd = try container.decodeIfPresent(.p12Pwd)
            provProfile = try container.decodeIfPresent(.provProfile)
            sdkBundle = try container.decodeIfPresent(.sdkBundle)
            slnPath = try container.decodeIfPresent(.slnPath)
            symlink = try container.decodeIfPresent(.symlink)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(args, forKey: .args)
            try container.encodeIfPresent(configuration, forKey: .configuration)
            try container.encodeIfPresent(isSimBuild, forKey: .isSimBuild)
            try container.encodeIfPresent(monoVersion, forKey: .monoVersion)
            try container.encodeIfPresent(p12File, forKey: .p12File)
            try container.encodeIfPresent(p12Pwd, forKey: .p12Pwd)
            try container.encodeIfPresent(provProfile, forKey: .provProfile)
            try container.encodeIfPresent(sdkBundle, forKey: .sdkBundle)
            try container.encodeIfPresent(slnPath, forKey: .slnPath)
            try container.encodeIfPresent(symlink, forKey: .symlink)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Xamarin else { return false }
          guard self.args == object.args else { return false }
          guard self.configuration == object.configuration else { return false }
          guard self.isSimBuild == object.isSimBuild else { return false }
          guard self.monoVersion == object.monoVersion else { return false }
          guard self.p12File == object.p12File else { return false }
          guard self.p12Pwd == object.p12Pwd else { return false }
          guard self.provProfile == object.provProfile else { return false }
          guard self.sdkBundle == object.sdkBundle else { return false }
          guard self.slnPath == object.slnPath else { return false }
          guard self.symlink == object.symlink else { return false }
          return true
        }

        public static func == (lhs: Xamarin, rhs: Xamarin) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** The branch build configuration for each toolset */
    public class Xcode: APIModel {

        public var appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFiles]?

        /** The build configuration of the target to archive */
        public var archiveConfiguration: String?

        public var automaticSigning: Bool?

        /** Path to Carthage file, if present */
        public var cartfilePath: String?

        public var certificateEncoded: String?

        public var certificateFileId: String?

        public var certificateFilename: String?

        public var certificatePassword: String?

        public var certificateUploadId: String?

        /** Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.
    By default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.
     */
        public var forceLegacyBuildSystem: Bool?

        /** Path to CococaPods file, if present */
        public var podfilePath: String?

        /** Xcode project/workspace path */
        public var projectOrWorkspacePath: String?

        public var provisioningProfileEncoded: String?

        public var provisioningProfileFileId: String?

        public var provisioningProfileFilename: String?

        public var provisioningProfileUploadId: String?

        public var scheme: String?

        /** The target id of the selected scheme to archive */
        public var targetToArchive: String?

        public var teamId: String?

        /** The selected pbxproject hash to the repositroy */
        public var xcodeProjectSha: String?

        /** Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default is latest stable version, at the time when the configuration is set. */
        public var xcodeVersion: String?

        public init(appExtensionProvisioningProfileFiles: [AppExtensionProvisioningProfileFiles]? = nil, archiveConfiguration: String? = nil, automaticSigning: Bool? = nil, cartfilePath: String? = nil, certificateEncoded: String? = nil, certificateFileId: String? = nil, certificateFilename: String? = nil, certificatePassword: String? = nil, certificateUploadId: String? = nil, forceLegacyBuildSystem: Bool? = nil, podfilePath: String? = nil, projectOrWorkspacePath: String? = nil, provisioningProfileEncoded: String? = nil, provisioningProfileFileId: String? = nil, provisioningProfileFilename: String? = nil, provisioningProfileUploadId: String? = nil, scheme: String? = nil, targetToArchive: String? = nil, teamId: String? = nil, xcodeProjectSha: String? = nil, xcodeVersion: String? = nil) {
            self.appExtensionProvisioningProfileFiles = appExtensionProvisioningProfileFiles
            self.archiveConfiguration = archiveConfiguration
            self.automaticSigning = automaticSigning
            self.cartfilePath = cartfilePath
            self.certificateEncoded = certificateEncoded
            self.certificateFileId = certificateFileId
            self.certificateFilename = certificateFilename
            self.certificatePassword = certificatePassword
            self.certificateUploadId = certificateUploadId
            self.forceLegacyBuildSystem = forceLegacyBuildSystem
            self.podfilePath = podfilePath
            self.projectOrWorkspacePath = projectOrWorkspacePath
            self.provisioningProfileEncoded = provisioningProfileEncoded
            self.provisioningProfileFileId = provisioningProfileFileId
            self.provisioningProfileFilename = provisioningProfileFilename
            self.provisioningProfileUploadId = provisioningProfileUploadId
            self.scheme = scheme
            self.targetToArchive = targetToArchive
            self.teamId = teamId
            self.xcodeProjectSha = xcodeProjectSha
            self.xcodeVersion = xcodeVersion
        }

        private enum CodingKeys: String, CodingKey {
            case appExtensionProvisioningProfileFiles
            case archiveConfiguration
            case automaticSigning
            case cartfilePath
            case certificateEncoded
            case certificateFileId
            case certificateFilename
            case certificatePassword
            case certificateUploadId
            case forceLegacyBuildSystem
            case podfilePath
            case projectOrWorkspacePath
            case provisioningProfileEncoded
            case provisioningProfileFileId
            case provisioningProfileFilename
            case provisioningProfileUploadId
            case scheme
            case targetToArchive
            case teamId
            case xcodeProjectSha
            case xcodeVersion
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            appExtensionProvisioningProfileFiles = try container.decodeArrayIfPresent(.appExtensionProvisioningProfileFiles)
            archiveConfiguration = try container.decodeIfPresent(.archiveConfiguration)
            automaticSigning = try container.decodeIfPresent(.automaticSigning)
            cartfilePath = try container.decodeIfPresent(.cartfilePath)
            certificateEncoded = try container.decodeIfPresent(.certificateEncoded)
            certificateFileId = try container.decodeIfPresent(.certificateFileId)
            certificateFilename = try container.decodeIfPresent(.certificateFilename)
            certificatePassword = try container.decodeIfPresent(.certificatePassword)
            certificateUploadId = try container.decodeIfPresent(.certificateUploadId)
            forceLegacyBuildSystem = try container.decodeIfPresent(.forceLegacyBuildSystem)
            podfilePath = try container.decodeIfPresent(.podfilePath)
            projectOrWorkspacePath = try container.decodeIfPresent(.projectOrWorkspacePath)
            provisioningProfileEncoded = try container.decodeIfPresent(.provisioningProfileEncoded)
            provisioningProfileFileId = try container.decodeIfPresent(.provisioningProfileFileId)
            provisioningProfileFilename = try container.decodeIfPresent(.provisioningProfileFilename)
            provisioningProfileUploadId = try container.decodeIfPresent(.provisioningProfileUploadId)
            scheme = try container.decodeIfPresent(.scheme)
            targetToArchive = try container.decodeIfPresent(.targetToArchive)
            teamId = try container.decodeIfPresent(.teamId)
            xcodeProjectSha = try container.decodeIfPresent(.xcodeProjectSha)
            xcodeVersion = try container.decodeIfPresent(.xcodeVersion)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(appExtensionProvisioningProfileFiles, forKey: .appExtensionProvisioningProfileFiles)
            try container.encodeIfPresent(archiveConfiguration, forKey: .archiveConfiguration)
            try container.encodeIfPresent(automaticSigning, forKey: .automaticSigning)
            try container.encodeIfPresent(cartfilePath, forKey: .cartfilePath)
            try container.encodeIfPresent(certificateEncoded, forKey: .certificateEncoded)
            try container.encodeIfPresent(certificateFileId, forKey: .certificateFileId)
            try container.encodeIfPresent(certificateFilename, forKey: .certificateFilename)
            try container.encodeIfPresent(certificatePassword, forKey: .certificatePassword)
            try container.encodeIfPresent(certificateUploadId, forKey: .certificateUploadId)
            try container.encodeIfPresent(forceLegacyBuildSystem, forKey: .forceLegacyBuildSystem)
            try container.encodeIfPresent(podfilePath, forKey: .podfilePath)
            try container.encodeIfPresent(projectOrWorkspacePath, forKey: .projectOrWorkspacePath)
            try container.encodeIfPresent(provisioningProfileEncoded, forKey: .provisioningProfileEncoded)
            try container.encodeIfPresent(provisioningProfileFileId, forKey: .provisioningProfileFileId)
            try container.encodeIfPresent(provisioningProfileFilename, forKey: .provisioningProfileFilename)
            try container.encodeIfPresent(provisioningProfileUploadId, forKey: .provisioningProfileUploadId)
            try container.encodeIfPresent(scheme, forKey: .scheme)
            try container.encodeIfPresent(targetToArchive, forKey: .targetToArchive)
            try container.encodeIfPresent(teamId, forKey: .teamId)
            try container.encodeIfPresent(xcodeProjectSha, forKey: .xcodeProjectSha)
            try container.encodeIfPresent(xcodeVersion, forKey: .xcodeVersion)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Xcode else { return false }
          guard self.appExtensionProvisioningProfileFiles == object.appExtensionProvisioningProfileFiles else { return false }
          guard self.archiveConfiguration == object.archiveConfiguration else { return false }
          guard self.automaticSigning == object.automaticSigning else { return false }
          guard self.cartfilePath == object.cartfilePath else { return false }
          guard self.certificateEncoded == object.certificateEncoded else { return false }
          guard self.certificateFileId == object.certificateFileId else { return false }
          guard self.certificateFilename == object.certificateFilename else { return false }
          guard self.certificatePassword == object.certificatePassword else { return false }
          guard self.certificateUploadId == object.certificateUploadId else { return false }
          guard self.forceLegacyBuildSystem == object.forceLegacyBuildSystem else { return false }
          guard self.podfilePath == object.podfilePath else { return false }
          guard self.projectOrWorkspacePath == object.projectOrWorkspacePath else { return false }
          guard self.provisioningProfileEncoded == object.provisioningProfileEncoded else { return false }
          guard self.provisioningProfileFileId == object.provisioningProfileFileId else { return false }
          guard self.provisioningProfileFilename == object.provisioningProfileFilename else { return false }
          guard self.provisioningProfileUploadId == object.provisioningProfileUploadId else { return false }
          guard self.scheme == object.scheme else { return false }
          guard self.targetToArchive == object.targetToArchive else { return false }
          guard self.teamId == object.teamId else { return false }
          guard self.xcodeProjectSha == object.xcodeProjectSha else { return false }
          guard self.xcodeVersion == object.xcodeVersion else { return false }
          return true
        }

        public static func == (lhs: Xcode, rhs: Xcode) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(android: Android? = nil, javascript: Javascript? = nil, xamarin: Xamarin? = nil, xcode: Xcode? = nil) {
        self.android = android
        self.javascript = javascript
        self.xamarin = xamarin
        self.xcode = xcode
    }

    private enum CodingKeys: String, CodingKey {
        case android
        case javascript
        case xamarin
        case xcode
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        android = try container.decodeIfPresent(.android)
        javascript = try container.decodeIfPresent(.javascript)
        xamarin = try container.decodeIfPresent(.xamarin)
        xcode = try container.decodeIfPresent(.xcode)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(android, forKey: .android)
        try container.encodeIfPresent(javascript, forKey: .javascript)
        try container.encodeIfPresent(xamarin, forKey: .xamarin)
        try container.encodeIfPresent(xcode, forKey: .xcode)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? BranchConfigurationToolsets else { return false }
      guard self.android == object.android else { return false }
      guard self.javascript == object.javascript else { return false }
      guard self.xamarin == object.xamarin else { return false }
      guard self.xcode == object.xcode else { return false }
      return true
    }

    public static func == (lhs: BranchConfigurationToolsets, rhs: BranchConfigurationToolsets) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
