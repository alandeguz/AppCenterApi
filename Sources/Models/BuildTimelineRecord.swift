//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class BuildTimelineRecord: APIModel {

    public var currentOperation: String?

    public var errorCount: Double?

    public var finishTime: String?

    public var id: String?

    public var issues: [Issues]?

    public var name: String?

    public var order: Double?

    public var percentComplete: Double?

    public var result: String?

    public var startTime: String?

    public var state: String?

    public var type: String?

    public var warningCount: Double?

    public init(currentOperation: String? = nil, errorCount: Double? = nil, finishTime: String? = nil, id: String? = nil, issues: [Issues]? = nil, name: String? = nil, order: Double? = nil, percentComplete: Double? = nil, result: String? = nil, startTime: String? = nil, state: String? = nil, type: String? = nil, warningCount: Double? = nil) {
        self.currentOperation = currentOperation
        self.errorCount = errorCount
        self.finishTime = finishTime
        self.id = id
        self.issues = issues
        self.name = name
        self.order = order
        self.percentComplete = percentComplete
        self.result = result
        self.startTime = startTime
        self.state = state
        self.type = type
        self.warningCount = warningCount
    }

    private enum CodingKeys: String, CodingKey {
        case currentOperation
        case errorCount
        case finishTime
        case id
        case issues
        case name
        case order
        case percentComplete
        case result
        case startTime
        case state
        case type
        case warningCount
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        currentOperation = try container.decodeIfPresent(.currentOperation)
        errorCount = try container.decodeIfPresent(.errorCount)
        finishTime = try container.decodeIfPresent(.finishTime)
        id = try container.decodeIfPresent(.id)
        issues = try container.decodeArrayIfPresent(.issues)
        name = try container.decodeIfPresent(.name)
        order = try container.decodeIfPresent(.order)
        percentComplete = try container.decodeIfPresent(.percentComplete)
        result = try container.decodeIfPresent(.result)
        startTime = try container.decodeIfPresent(.startTime)
        state = try container.decodeIfPresent(.state)
        type = try container.decodeIfPresent(.type)
        warningCount = try container.decodeIfPresent(.warningCount)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(currentOperation, forKey: .currentOperation)
        try container.encodeIfPresent(errorCount, forKey: .errorCount)
        try container.encodeIfPresent(finishTime, forKey: .finishTime)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(issues, forKey: .issues)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(order, forKey: .order)
        try container.encodeIfPresent(percentComplete, forKey: .percentComplete)
        try container.encodeIfPresent(result, forKey: .result)
        try container.encodeIfPresent(startTime, forKey: .startTime)
        try container.encodeIfPresent(state, forKey: .state)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(warningCount, forKey: .warningCount)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? BuildTimelineRecord else { return false }
      guard self.currentOperation == object.currentOperation else { return false }
      guard self.errorCount == object.errorCount else { return false }
      guard self.finishTime == object.finishTime else { return false }
      guard self.id == object.id else { return false }
      guard self.issues == object.issues else { return false }
      guard self.name == object.name else { return false }
      guard self.order == object.order else { return false }
      guard self.percentComplete == object.percentComplete else { return false }
      guard self.result == object.result else { return false }
      guard self.startTime == object.startTime else { return false }
      guard self.state == object.state else { return false }
      guard self.type == object.type else { return false }
      guard self.warningCount == object.warningCount else { return false }
      return true
    }

    public static func == (lhs: BuildTimelineRecord, rhs: BuildTimelineRecord) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
