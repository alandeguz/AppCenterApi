//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class AppResponse: APIModel {

    /** The OS the app will be running on */
    public enum Os: String, Codable {
        case android = "Android"
        case iOS = "iOS"
        case macOS = "macOS"
        case tizen = "Tizen"
        case tvOS = "tvOS"
        case windows = "Windows"
        case linux = "Linux"
        case custom = "Custom"

        public static let cases: [Os] = [
          .android,
          .iOS,
          .macOS,
          .tizen,
          .tvOS,
          .windows,
          .linux,
          .custom,
        ]
    }

    /** The unique ID (UUID) of the app */
    public var id: ID

    /** The display name of the app */
    public var displayName: String

    /** The name of the app used in URLs */
    public var name: String

    /** The OS the app will be running on */
    public var os: Os

    /** The information about the app's owner */
    public var owner: Owner

    /** The description of the app */
    public var description: String?

    /** The string representation of the source of the app's icon */
    public var iconSource: String?

    /** The string representation of the URL pointing to the app's icon */
    public var iconURL: String?

    /** A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase */
    public var releaseType: String?

    public class Owner: APIModel {

        /** The owner type. Can either be 'org' or 'user' */
        public enum `Type`: String, Codable {
            case org = "org"
            case user = "user"

            public static let cases: [`Type`] = [
              .org,
              .user,
            ]
        }

        /** The unique id (UUID) of the owner */
        public var id: ID

        /** The owner's display name */
        public var displayName: String

        /** The unique name that used to identify the owner */
        public var name: String

        /** The owner type. Can either be 'org' or 'user' */
        public var type: `Type`

        /** The avatar URL of the owner */
        public var avatarURL: String?

        /** The owner's email address */
        public var email: String?

        public init(id: ID, displayName: String, name: String, type: `Type`, avatarURL: String? = nil, email: String? = nil) {
            self.id = id
            self.displayName = displayName
            self.name = name
            self.type = type
            self.avatarURL = avatarURL
            self.email = email
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case displayName = "display_name"
            case name
            case type
            case avatarURL = "avatar_url"
            case email
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            id = try container.decode(.id)
            displayName = try container.decode(.displayName)
            name = try container.decode(.name)
            type = try container.decode(.type)
            avatarURL = try container.decodeIfPresent(.avatarURL)
            email = try container.decodeIfPresent(.email)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(id, forKey: .id)
            try container.encode(displayName, forKey: .displayName)
            try container.encode(name, forKey: .name)
            try container.encode(type, forKey: .type)
            try container.encodeIfPresent(avatarURL, forKey: .avatarURL)
            try container.encodeIfPresent(email, forKey: .email)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Owner else { return false }
          guard self.id == object.id else { return false }
          guard self.displayName == object.displayName else { return false }
          guard self.name == object.name else { return false }
          guard self.type == object.type else { return false }
          guard self.avatarURL == object.avatarURL else { return false }
          guard self.email == object.email else { return false }
          return true
        }

        public static func == (lhs: Owner, rhs: Owner) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(id: ID, displayName: String, name: String, os: Os, owner: Owner, description: String? = nil, iconSource: String? = nil, iconURL: String? = nil, releaseType: String? = nil) {
        self.id = id
        self.displayName = displayName
        self.name = name
        self.os = os
        self.owner = owner
        self.description = description
        self.iconSource = iconSource
        self.iconURL = iconURL
        self.releaseType = releaseType
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName = "display_name"
        case name
        case os
        case owner
        case description
        case iconSource = "icon_source"
        case iconURL = "icon_url"
        case releaseType = "release_type"
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decode(.id)
        displayName = try container.decode(.displayName)
        name = try container.decode(.name)
        os = try container.decode(.os)
        owner = try container.decode(.owner)
        description = try container.decodeIfPresent(.description)
        iconSource = try container.decodeIfPresent(.iconSource)
        iconURL = try container.decodeIfPresent(.iconURL)
        releaseType = try container.decodeIfPresent(.releaseType)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(id, forKey: .id)
        try container.encode(displayName, forKey: .displayName)
        try container.encode(name, forKey: .name)
        try container.encode(os, forKey: .os)
        try container.encode(owner, forKey: .owner)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(iconSource, forKey: .iconSource)
        try container.encodeIfPresent(iconURL, forKey: .iconURL)
        try container.encodeIfPresent(releaseType, forKey: .releaseType)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? AppResponse else { return false }
      guard self.id == object.id else { return false }
      guard self.displayName == object.displayName else { return false }
      guard self.name == object.name else { return false }
      guard self.os == object.os else { return false }
      guard self.owner == object.owner else { return false }
      guard self.description == object.description else { return false }
      guard self.iconSource == object.iconSource else { return false }
      guard self.iconURL == object.iconURL else { return false }
      guard self.releaseType == object.releaseType else { return false }
      return true
    }

    public static func == (lhs: AppResponse, rhs: AppResponse) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
