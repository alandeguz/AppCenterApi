//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** The branch build status */
public class BranchStatus: APIModel {

    public var configured: Bool

    public var lastBuild: LastBuild?

    public var additionalProperties: [String: Anonymous] = [:]

    /** The branch build status */
    public class LastBuild: APIModel {

        /** The build ID */
        public var id: Int

        /** The build number */
        public var buildNumber: String

        /** The time the build was queued */
        public var queueTime: String

        /** The build status */
        public var status: String

        /** The build result */
        public var result: String

        /** The source branch name */
        public var sourceBranch: String

        /** The source SHA */
        public var sourceVersion: String

        /** The time the build was finished */
        public var finishTime: String?

        /** The time the build status was last changed */
        public var lastChangedDate: String?

        /** The time the build was started */
        public var startTime: String?

        public var additionalProperties: [String: Anonymous] = [:]

        public init(id: Int, buildNumber: String, queueTime: String, status: String, result: String, sourceBranch: String, sourceVersion: String, finishTime: String? = nil, lastChangedDate: String? = nil, startTime: String? = nil) {
            self.id = id
            self.buildNumber = buildNumber
            self.queueTime = queueTime
            self.status = status
            self.result = result
            self.sourceBranch = sourceBranch
            self.sourceVersion = sourceVersion
            self.finishTime = finishTime
            self.lastChangedDate = lastChangedDate
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case buildNumber
            case queueTime
            case status
            case result
            case sourceBranch
            case sourceVersion
            case finishTime
            case lastChangedDate
            case startTime
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            id = try container.decode(.id)
            buildNumber = try container.decode(.buildNumber)
            queueTime = try container.decode(.queueTime)
            status = try container.decode(.status)
            result = try container.decode(.result)
            sourceBranch = try container.decode(.sourceBranch)
            sourceVersion = try container.decode(.sourceVersion)
            finishTime = try container.decodeIfPresent(.finishTime)
            lastChangedDate = try container.decodeIfPresent(.lastChangedDate)
            startTime = try container.decodeIfPresent(.startTime)

            let additionalPropertiesContainer = try decoder.container(keyedBy: StringCodingKey.self)
            var additionalProperties = try additionalPropertiesContainer.toDictionary()
            additionalProperties.removeValue(forKey: "id")
            additionalProperties.removeValue(forKey: "buildNumber")
            additionalProperties.removeValue(forKey: "queueTime")
            additionalProperties.removeValue(forKey: "status")
            additionalProperties.removeValue(forKey: "result")
            additionalProperties.removeValue(forKey: "sourceBranch")
            additionalProperties.removeValue(forKey: "sourceVersion")
            additionalProperties.removeValue(forKey: "finishTime")
            additionalProperties.removeValue(forKey: "lastChangedDate")
            additionalProperties.removeValue(forKey: "startTime")
            var decodedAdditionalProperties: [String: Anonymous] = [:]
            for key in additionalProperties.keys {
                decodedAdditionalProperties[key] = try additionalPropertiesContainer.decode(StringCodingKey(string: key))
            }
            self.additionalProperties = decodedAdditionalProperties
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(id, forKey: .id)
            try container.encode(buildNumber, forKey: .buildNumber)
            try container.encode(queueTime, forKey: .queueTime)
            try container.encode(status, forKey: .status)
            try container.encode(result, forKey: .result)
            try container.encode(sourceBranch, forKey: .sourceBranch)
            try container.encode(sourceVersion, forKey: .sourceVersion)
            try container.encodeIfPresent(finishTime, forKey: .finishTime)
            try container.encodeIfPresent(lastChangedDate, forKey: .lastChangedDate)
            try container.encodeIfPresent(startTime, forKey: .startTime)

            var additionalPropertiesContainer = encoder.container(keyedBy: StringCodingKey.self)
            for (key, value) in additionalProperties {
                try additionalPropertiesContainer.encode(value, forKey: StringCodingKey(string: key))
            }
        }

        public subscript(key: String) -> Anonymous? {
            get {
                return additionalProperties[key]
            }
            set {
                additionalProperties[key] = newValue
            }
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? LastBuild else { return false }
          guard self.id == object.id else { return false }
          guard self.buildNumber == object.buildNumber else { return false }
          guard self.queueTime == object.queueTime else { return false }
          guard self.status == object.status else { return false }
          guard self.result == object.result else { return false }
          guard self.sourceBranch == object.sourceBranch else { return false }
          guard self.sourceVersion == object.sourceVersion else { return false }
          guard self.finishTime == object.finishTime else { return false }
          guard self.lastChangedDate == object.lastChangedDate else { return false }
          guard self.startTime == object.startTime else { return false }
          guard NSDictionary(dictionary: self.additionalProperties).isEqual(to: object.additionalProperties) else { return false }
          return true
        }

        public static func == (lhs: LastBuild, rhs: LastBuild) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(configured: Bool, lastBuild: LastBuild? = nil) {
        self.configured = configured
        self.lastBuild = lastBuild
    }

    private enum CodingKeys: String, CodingKey {
        case configured
        case lastBuild
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        configured = try container.decode(.configured)
        lastBuild = try container.decodeIfPresent(.lastBuild)

        let additionalPropertiesContainer = try decoder.container(keyedBy: StringCodingKey.self)
        var additionalProperties = try additionalPropertiesContainer.toDictionary()
        additionalProperties.removeValue(forKey: "configured")
        additionalProperties.removeValue(forKey: "lastBuild")
        var decodedAdditionalProperties: [String: Anonymous] = [:]
        for key in additionalProperties.keys {
            decodedAdditionalProperties[key] = try additionalPropertiesContainer.decode(StringCodingKey(string: key))
        }
        self.additionalProperties = decodedAdditionalProperties
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(configured, forKey: .configured)
        try container.encodeIfPresent(lastBuild, forKey: .lastBuild)

        var additionalPropertiesContainer = encoder.container(keyedBy: StringCodingKey.self)
        for (key, value) in additionalProperties {
            try additionalPropertiesContainer.encode(value, forKey: StringCodingKey(string: key))
        }
    }

    public subscript(key: String) -> Anonymous? {
        get {
            return additionalProperties[key]
        }
        set {
            additionalProperties[key] = newValue
        }
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? BranchStatus else { return false }
      guard self.configured == object.configured else { return false }
      guard self.lastBuild == object.lastBuild else { return false }
      guard NSDictionary(dictionary: self.additionalProperties).isEqual(to: object.additionalProperties) else { return false }
      return true
    }

    public static func == (lhs: BranchStatus, rhs: BranchStatus) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
