//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Usage section in the Billing Information */
public class BillingResourceUsage: APIModel {

    /** Resource usage for a single Mobile Center service */
    public var buildService: BuildService?

    /** Resource usage for a single Mobile Center service */
    public var testService: TestService?

    /** Usage section in the Billing Information */
    public class BuildService: APIModel {

        /** Usage for a single period */
        public var currentUsagePeriod: CurrentUsagePeriod?

        /** Usage section in the Billing Information */
        public class CurrentUsagePeriod: APIModel {

            /** A collection of named numeric values */
            public var byAccount: [String: Double]?

            /** A collection of  named numeric values grouped by app */
            public var byApp: [String: [String: Double]]?

            /** Exclusive end time of the usage period. */
            public var endTime: String?

            /** Inclusive start time of the usage period */
            public var startTime: String?

            public init(byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil, endTime: String? = nil, startTime: String? = nil) {
                self.byAccount = byAccount
                self.byApp = byApp
                self.endTime = endTime
                self.startTime = startTime
            }

            private enum CodingKeys: String, CodingKey {
                case byAccount
                case byApp
                case endTime
                case startTime
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                byAccount = try container.decodeIfPresent(.byAccount)
                byApp = try container.decodeIfPresent(.byApp)
                endTime = try container.decodeIfPresent(.endTime)
                startTime = try container.decodeIfPresent(.startTime)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(byAccount, forKey: .byAccount)
                try container.encodeIfPresent(byApp, forKey: .byApp)
                try container.encodeIfPresent(endTime, forKey: .endTime)
                try container.encodeIfPresent(startTime, forKey: .startTime)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? CurrentUsagePeriod else { return false }
              guard self.byAccount == object.byAccount else { return false }
              guard self.byApp == object.byApp else { return false }
              guard self.endTime == object.endTime else { return false }
              guard self.startTime == object.startTime else { return false }
              return true
            }

            public static func == (lhs: CurrentUsagePeriod, rhs: CurrentUsagePeriod) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
            self.currentUsagePeriod = currentUsagePeriod
        }

        private enum CodingKeys: String, CodingKey {
            case currentUsagePeriod
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            currentUsagePeriod = try container.decodeIfPresent(.currentUsagePeriod)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(currentUsagePeriod, forKey: .currentUsagePeriod)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? BuildService else { return false }
          guard self.currentUsagePeriod == object.currentUsagePeriod else { return false }
          return true
        }

        public static func == (lhs: BuildService, rhs: BuildService) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** Usage section in the Billing Information */
    public class TestService: APIModel {

        /** Usage for a single period */
        public var currentUsagePeriod: CurrentUsagePeriod?

        /** Usage section in the Billing Information */
        public class CurrentUsagePeriod: APIModel {

            /** A collection of named numeric values */
            public var byAccount: [String: Double]?

            /** A collection of  named numeric values grouped by app */
            public var byApp: [String: [String: Double]]?

            /** Exclusive end time of the usage period. */
            public var endTime: String?

            /** Inclusive start time of the usage period */
            public var startTime: String?

            public init(byAccount: [String: Double]? = nil, byApp: [String: [String: Double]]? = nil, endTime: String? = nil, startTime: String? = nil) {
                self.byAccount = byAccount
                self.byApp = byApp
                self.endTime = endTime
                self.startTime = startTime
            }

            private enum CodingKeys: String, CodingKey {
                case byAccount
                case byApp
                case endTime
                case startTime
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                byAccount = try container.decodeIfPresent(.byAccount)
                byApp = try container.decodeIfPresent(.byApp)
                endTime = try container.decodeIfPresent(.endTime)
                startTime = try container.decodeIfPresent(.startTime)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(byAccount, forKey: .byAccount)
                try container.encodeIfPresent(byApp, forKey: .byApp)
                try container.encodeIfPresent(endTime, forKey: .endTime)
                try container.encodeIfPresent(startTime, forKey: .startTime)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? CurrentUsagePeriod else { return false }
              guard self.byAccount == object.byAccount else { return false }
              guard self.byApp == object.byApp else { return false }
              guard self.endTime == object.endTime else { return false }
              guard self.startTime == object.startTime else { return false }
              return true
            }

            public static func == (lhs: CurrentUsagePeriod, rhs: CurrentUsagePeriod) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(currentUsagePeriod: CurrentUsagePeriod? = nil) {
            self.currentUsagePeriod = currentUsagePeriod
        }

        private enum CodingKeys: String, CodingKey {
            case currentUsagePeriod
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            currentUsagePeriod = try container.decodeIfPresent(.currentUsagePeriod)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(currentUsagePeriod, forKey: .currentUsagePeriod)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? TestService else { return false }
          guard self.currentUsagePeriod == object.currentUsagePeriod else { return false }
          return true
        }

        public static func == (lhs: TestService, rhs: TestService) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(buildService: BuildService? = nil, testService: TestService? = nil) {
        self.buildService = buildService
        self.testService = testService
    }

    private enum CodingKeys: String, CodingKey {
        case buildService
        case testService
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        buildService = try container.decodeIfPresent(.buildService)
        testService = try container.decodeIfPresent(.testService)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(buildService, forKey: .buildService)
        try container.encodeIfPresent(testService, forKey: .testService)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? BillingResourceUsage else { return false }
      guard self.buildService == object.buildService else { return false }
      guard self.testService == object.testService else { return false }
      return true
    }

    public static func == (lhs: BillingResourceUsage, rhs: BillingResourceUsage) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
