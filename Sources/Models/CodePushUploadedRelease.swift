//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class CodePushUploadedRelease: APIModel {

    /** The upload metadata from the release initialization step. */
    public var releaseUpload: ReleaseUpload

    /** the binary version of the application */
    public var targetBinaryVersion: String

    /** This specifies which deployment you want to release the update to. Default is Staging. */
    public var deploymentName: String?

    /** This provides an optional "change log" for the deployment. */
    public var description: String?

    /** This specifies whether an update should be downloadable by end users or not. */
    public var disabled: Bool?

    /** This specifies whether the update should be considered mandatory or not (e.g. it includes a critical security fix). */
    public var mandatory: Bool?

    /** This specifies that if the update is identical to the latest release on the deployment, the CLI should generate a warning instead of an error. */
    public var noDuplicateReleaseError: Bool?

    /** This specifies the percentage of users (as an integer between 1 and 100) that should be eligible to receive this update. */
    public var rollout: Int?

    public class ReleaseUpload: APIModel {

        /** The ID for the newly created upload. It is going to be required later in the process. */
        public var id: ID

        /** The URL domain used to upload the release. */
        public var uploadDomain: String

        /** The URL encoded token used for upload permissions. */
        public var token: String

        public init(id: ID, uploadDomain: String, token: String) {
            self.id = id
            self.uploadDomain = uploadDomain
            self.token = token
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case uploadDomain = "upload_domain"
            case token
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            id = try container.decode(.id)
            uploadDomain = try container.decode(.uploadDomain)
            token = try container.decode(.token)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(id, forKey: .id)
            try container.encode(uploadDomain, forKey: .uploadDomain)
            try container.encode(token, forKey: .token)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? ReleaseUpload else { return false }
          guard self.id == object.id else { return false }
          guard self.uploadDomain == object.uploadDomain else { return false }
          guard self.token == object.token else { return false }
          return true
        }

        public static func == (lhs: ReleaseUpload, rhs: ReleaseUpload) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(releaseUpload: ReleaseUpload, targetBinaryVersion: String, deploymentName: String? = nil, description: String? = nil, disabled: Bool? = nil, mandatory: Bool? = nil, noDuplicateReleaseError: Bool? = nil, rollout: Int? = nil) {
        self.releaseUpload = releaseUpload
        self.targetBinaryVersion = targetBinaryVersion
        self.deploymentName = deploymentName
        self.description = description
        self.disabled = disabled
        self.mandatory = mandatory
        self.noDuplicateReleaseError = noDuplicateReleaseError
        self.rollout = rollout
    }

    private enum CodingKeys: String, CodingKey {
        case releaseUpload = "release_upload"
        case targetBinaryVersion = "target_binary_version"
        case deploymentName = "deployment_name"
        case description
        case disabled
        case mandatory
        case noDuplicateReleaseError = "no_duplicate_release_error"
        case rollout
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        releaseUpload = try container.decode(.releaseUpload)
        targetBinaryVersion = try container.decode(.targetBinaryVersion)
        deploymentName = try container.decodeIfPresent(.deploymentName)
        description = try container.decodeIfPresent(.description)
        disabled = try container.decodeIfPresent(.disabled)
        mandatory = try container.decodeIfPresent(.mandatory)
        noDuplicateReleaseError = try container.decodeIfPresent(.noDuplicateReleaseError)
        rollout = try container.decodeIfPresent(.rollout)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(releaseUpload, forKey: .releaseUpload)
        try container.encode(targetBinaryVersion, forKey: .targetBinaryVersion)
        try container.encodeIfPresent(deploymentName, forKey: .deploymentName)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(disabled, forKey: .disabled)
        try container.encodeIfPresent(mandatory, forKey: .mandatory)
        try container.encodeIfPresent(noDuplicateReleaseError, forKey: .noDuplicateReleaseError)
        try container.encodeIfPresent(rollout, forKey: .rollout)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? CodePushUploadedRelease else { return false }
      guard self.releaseUpload == object.releaseUpload else { return false }
      guard self.targetBinaryVersion == object.targetBinaryVersion else { return false }
      guard self.deploymentName == object.deploymentName else { return false }
      guard self.description == object.description else { return false }
      guard self.disabled == object.disabled else { return false }
      guard self.mandatory == object.mandatory else { return false }
      guard self.noDuplicateReleaseError == object.noDuplicateReleaseError else { return false }
      guard self.rollout == object.rollout else { return false }
      return true
    }

    public static func == (lhs: CodePushUploadedRelease, rhs: CodePushUploadedRelease) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
