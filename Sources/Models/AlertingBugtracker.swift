//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Alerting bugtracker resource */
public class AlertingBugtracker: APIModel {

    /** Event types enabled for bugtracker */
    public enum EventTypes: String, Codable {
        case newCrashGroupCreated = "newCrashGroupCreated"
        case newAppReleased = "newAppReleased"

        public static let cases: [EventTypes] = [
          .newCrashGroupCreated,
          .newAppReleased,
        ]
    }

    /** bugtracker state */
    public enum State: String, Codable {
        case enabled = "enabled"
        case disabled = "disabled"
        case unauthorized = "unauthorized"

        public static let cases: [State] = [
          .enabled,
          .disabled,
          .unauthorized,
        ]
    }

    /** Event types enabled for bugtracker */
    public var eventTypes: [EventTypes]?

    /** Bugtracker specific settings */
    public var settings: Settings?

    /** bugtracker state */
    public var state: State?

    /** ID of OAuth token */
    public var tokenId: String?

    /** type of bugtracker */
    public var type: RepoTypeParameter?

    /** Alerting bugtracker resource */
    public class Settings: APIModel {

        /** type of bugtracker */
        public var type: RepoTypeParameter

        public var ownerName: String

        public var callbackURL: String?

        public init(type: RepoTypeParameter, ownerName: String, callbackURL: String? = nil) {
            self.type = type
            self.ownerName = ownerName
            self.callbackURL = callbackURL
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case ownerName = "owner_name"
            case callbackURL = "callback_url"
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            type = try container.decode(.type)
            ownerName = try container.decode(.ownerName)
            callbackURL = try container.decodeIfPresent(.callbackURL)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(type, forKey: .type)
            try container.encode(ownerName, forKey: .ownerName)
            try container.encodeIfPresent(callbackURL, forKey: .callbackURL)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Settings else { return false }
          guard self.type == object.type else { return false }
          guard self.ownerName == object.ownerName else { return false }
          guard self.callbackURL == object.callbackURL else { return false }
          return true
        }

        public static func == (lhs: Settings, rhs: Settings) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(eventTypes: [EventTypes]? = nil, settings: Settings? = nil, state: State? = nil, tokenId: String? = nil, type: RepoTypeParameter? = nil) {
        self.eventTypes = eventTypes
        self.settings = settings
        self.state = state
        self.tokenId = tokenId
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case eventTypes = "event_types"
        case settings
        case state
        case tokenId = "token_id"
        case type
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        eventTypes = try container.decodeArrayIfPresent(.eventTypes)
        settings = try container.decodeIfPresent(.settings)
        state = try container.decodeIfPresent(.state)
        tokenId = try container.decodeIfPresent(.tokenId)
        type = try container.decodeIfPresent(.type)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(eventTypes, forKey: .eventTypes)
        try container.encodeIfPresent(settings, forKey: .settings)
        try container.encodeIfPresent(state, forKey: .state)
        try container.encodeIfPresent(tokenId, forKey: .tokenId)
        try container.encodeIfPresent(type, forKey: .type)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? AlertingBugtracker else { return false }
      guard self.eventTypes == object.eventTypes else { return false }
      guard self.settings == object.settings else { return false }
      guard self.state == object.state else { return false }
      guard self.tokenId == object.tokenId else { return false }
      guard self.type == object.type else { return false }
      return true
    }

    public static func == (lhs: AlertingBugtracker, rhs: AlertingBugtracker) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
