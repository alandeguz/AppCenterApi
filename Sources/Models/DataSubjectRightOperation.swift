//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class DataSubjectRightOperation: APIModel {

    /** Request type */
    public enum RequestType: String, Codable {
        case unsupported = "Unsupported"
        case delete = "Delete"
        case purge = "Purge"
        case undoDelete = "UndoDelete"
        case scheduled = "Scheduled"
        case appDelete = "AppDelete"
        case appPurge = "AppPurge"
        case appUndoDelete = "AppUndoDelete"
        case export = "Export"
        case customerAccountDelete = "CustomerAccountDelete"
        case customerAccountExport = "CustomerAccountExport"
        case customerUserDelete = "CustomerUserDelete"
        case customerUserExport = "CustomerUserExport"

        public static let cases: [RequestType] = [
          .unsupported,
          .delete,
          .purge,
          .undoDelete,
          .scheduled,
          .appDelete,
          .appPurge,
          .appUndoDelete,
          .export,
          .customerAccountDelete,
          .customerAccountExport,
          .customerUserDelete,
          .customerUserExport,
        ]
    }

    /** Operation status */
    public enum Status: String, Codable {
        case none = "None"
        case created = "Created"
        case queued = "Queued"
        case inProgress = "InProgress"
        case completed = "Completed"
        case failed = "Failed"

        public static let cases: [Status] = [
          .none,
          .created,
          .queued,
          .inProgress,
          .completed,
          .failed,
        ]
    }

    /** Unique request identifier */
    public var requestId: ID

    /** Unique operation identifier */
    public var operationId: ID

    /** Request type */
    public var requestType: RequestType

    /** Operation status */
    public var status: Status

    /** Participant to execute the response */
    public var participant: String

    /** JSON object decribing what to delete (TODO - make separate definition?) */
    public var context: String

    /** Application identifier if applicable */
    public var appId: String?

    /** String field to be used by participant for any intermediate statuses or data they need to save */
    public var participantData: String?

    public init(requestId: ID, operationId: ID, requestType: RequestType, status: Status, participant: String, context: String, appId: String? = nil, participantData: String? = nil) {
        self.requestId = requestId
        self.operationId = operationId
        self.requestType = requestType
        self.status = status
        self.participant = participant
        self.context = context
        self.appId = appId
        self.participantData = participantData
    }

    private enum CodingKeys: String, CodingKey {
        case requestId
        case operationId
        case requestType
        case status
        case participant
        case context
        case appId
        case participantData
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        requestId = try container.decode(.requestId)
        operationId = try container.decode(.operationId)
        requestType = try container.decode(.requestType)
        status = try container.decode(.status)
        participant = try container.decode(.participant)
        context = try container.decode(.context)
        appId = try container.decodeIfPresent(.appId)
        participantData = try container.decodeIfPresent(.participantData)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(requestId, forKey: .requestId)
        try container.encode(operationId, forKey: .operationId)
        try container.encode(requestType, forKey: .requestType)
        try container.encode(status, forKey: .status)
        try container.encode(participant, forKey: .participant)
        try container.encode(context, forKey: .context)
        try container.encodeIfPresent(appId, forKey: .appId)
        try container.encodeIfPresent(participantData, forKey: .participantData)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? DataSubjectRightOperation else { return false }
      guard self.requestId == object.requestId else { return false }
      guard self.operationId == object.operationId else { return false }
      guard self.requestType == object.requestType else { return false }
      guard self.status == object.status else { return false }
      guard self.participant == object.participant else { return false }
      guard self.context == object.context else { return false }
      guard self.appId == object.appId else { return false }
      guard self.participantData == object.participantData else { return false }
      return true
    }

    public static func == (lhs: DataSubjectRightOperation, rhs: DataSubjectRightOperation) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
