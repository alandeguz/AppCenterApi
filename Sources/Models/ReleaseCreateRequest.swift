//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** A request containing information for creating a release. */
public class ReleaseCreateRequest: APIModel {

    /** MD5 checksum of the release binary. */
    public var fingerprint: String

    /** The release's size in bytes. */
    public var size: Int

    /** The upload id associated with the release, to map to the releases upload table. */
    public var uploadId: String

    /** iOS app extension provisioning profiles included in the release. */
    public var appexProvisioningProfiles: [AppexProvisioningProfiles]?

    /** The release's short version.<br>
For iOS: CFBundleShortVersionString from info.plist.<br>
For Android: android:versionName from AppManifest.xml.
 */
    public var buildVersion: String?

    /** The release's device family. */
    public var deviceFamily: String?

    /** The file extension of the asset. Does not include the initial period. */
    public var fileExtension: String?

    /** The assetId associated with the icon uploaded to app center file upload service. */
    public var iconAssetId: String?

    /** A list of UUIDs for architectures for an iOS app. */
    public var ipaUuids: [IpaUuids]?

    /** The languages supported by the release. Limited to 510 characters in a serialized array. */
    public var languages: [String]?

    /** The release's minimum required operating system. */
    public var minimumOsVersion: String?

    /** The URL to the release's binary. */
    public var packageURL: String?

    /** An object containing information about an iOS provisioning profile. */
    public var provision: Provision?

    /** If true this release was uploaded to the AKS upload proxy */
    public var proxyFlow: Bool?

    /** The identifier of the app's bundle. */
    public var uniqueIdentifier: String?

    /** The release's version.<br>
For iOS: CFBundleVersion from info.plist.<br>
For Android: android:versionCode from AppManifest.xml.
 */
    public var version: String?

    /** A request containing information for creating a release. */
    public class Provision: APIModel {

        /** A request containing information for creating a release. */
        public enum ProfileType: String, Codable {
            case adhoc = "adhoc"
            case enterprise = "enterprise"
            case other = "other"

            public static let cases: [ProfileType] = [
              .adhoc,
              .enterprise,
              .other,
            ]
        }

        /** The name of the provisioning profile. */
        public var name: String

        /** The application identifier. */
        public var applicationIdentifier: String

        /** The team identifier. */
        public var teamIdentifier: String

        public var profileType: ProfileType

        /** The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z */
        public var expiredAt: DateTime

        public var udids: [String]?

        public init(name: String, applicationIdentifier: String, teamIdentifier: String, profileType: ProfileType, expiredAt: DateTime, udids: [String]? = nil) {
            self.name = name
            self.applicationIdentifier = applicationIdentifier
            self.teamIdentifier = teamIdentifier
            self.profileType = profileType
            self.expiredAt = expiredAt
            self.udids = udids
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case applicationIdentifier = "application_identifier"
            case teamIdentifier = "team_identifier"
            case profileType = "profile_type"
            case expiredAt = "expired_at"
            case udids
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            name = try container.decode(.name)
            applicationIdentifier = try container.decode(.applicationIdentifier)
            teamIdentifier = try container.decode(.teamIdentifier)
            profileType = try container.decode(.profileType)
            expiredAt = try container.decode(.expiredAt)
            udids = try container.decodeArrayIfPresent(.udids)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(name, forKey: .name)
            try container.encode(applicationIdentifier, forKey: .applicationIdentifier)
            try container.encode(teamIdentifier, forKey: .teamIdentifier)
            try container.encode(profileType, forKey: .profileType)
            try container.encode(expiredAt, forKey: .expiredAt)
            try container.encodeIfPresent(udids, forKey: .udids)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Provision else { return false }
          guard self.name == object.name else { return false }
          guard self.applicationIdentifier == object.applicationIdentifier else { return false }
          guard self.teamIdentifier == object.teamIdentifier else { return false }
          guard self.profileType == object.profileType else { return false }
          guard self.expiredAt == object.expiredAt else { return false }
          guard self.udids == object.udids else { return false }
          return true
        }

        public static func == (lhs: Provision, rhs: Provision) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(fingerprint: String, size: Int, uploadId: String, appexProvisioningProfiles: [AppexProvisioningProfiles]? = nil, buildVersion: String? = nil, deviceFamily: String? = nil, fileExtension: String? = nil, iconAssetId: String? = nil, ipaUuids: [IpaUuids]? = nil, languages: [String]? = nil, minimumOsVersion: String? = nil, packageURL: String? = nil, provision: Provision? = nil, proxyFlow: Bool? = nil, uniqueIdentifier: String? = nil, version: String? = nil) {
        self.fingerprint = fingerprint
        self.size = size
        self.uploadId = uploadId
        self.appexProvisioningProfiles = appexProvisioningProfiles
        self.buildVersion = buildVersion
        self.deviceFamily = deviceFamily
        self.fileExtension = fileExtension
        self.iconAssetId = iconAssetId
        self.ipaUuids = ipaUuids
        self.languages = languages
        self.minimumOsVersion = minimumOsVersion
        self.packageURL = packageURL
        self.provision = provision
        self.proxyFlow = proxyFlow
        self.uniqueIdentifier = uniqueIdentifier
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case fingerprint
        case size
        case uploadId = "upload_id"
        case appexProvisioningProfiles = "appex_provisioning_profiles"
        case buildVersion = "build_version"
        case deviceFamily = "device_family"
        case fileExtension = "file_extension"
        case iconAssetId = "icon_asset_id"
        case ipaUuids = "ipa_uuids"
        case languages
        case minimumOsVersion = "minimum_os_version"
        case packageURL = "package_url"
        case provision
        case proxyFlow = "proxy_flow"
        case uniqueIdentifier = "unique_identifier"
        case version
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        fingerprint = try container.decode(.fingerprint)
        size = try container.decode(.size)
        uploadId = try container.decode(.uploadId)
        appexProvisioningProfiles = try container.decodeArrayIfPresent(.appexProvisioningProfiles)
        buildVersion = try container.decodeIfPresent(.buildVersion)
        deviceFamily = try container.decodeIfPresent(.deviceFamily)
        fileExtension = try container.decodeIfPresent(.fileExtension)
        iconAssetId = try container.decodeIfPresent(.iconAssetId)
        ipaUuids = try container.decodeArrayIfPresent(.ipaUuids)
        languages = try container.decodeArrayIfPresent(.languages)
        minimumOsVersion = try container.decodeIfPresent(.minimumOsVersion)
        packageURL = try container.decodeIfPresent(.packageURL)
        provision = try container.decodeIfPresent(.provision)
        proxyFlow = try container.decodeIfPresent(.proxyFlow)
        uniqueIdentifier = try container.decodeIfPresent(.uniqueIdentifier)
        version = try container.decodeIfPresent(.version)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(fingerprint, forKey: .fingerprint)
        try container.encode(size, forKey: .size)
        try container.encode(uploadId, forKey: .uploadId)
        try container.encodeIfPresent(appexProvisioningProfiles, forKey: .appexProvisioningProfiles)
        try container.encodeIfPresent(buildVersion, forKey: .buildVersion)
        try container.encodeIfPresent(deviceFamily, forKey: .deviceFamily)
        try container.encodeIfPresent(fileExtension, forKey: .fileExtension)
        try container.encodeIfPresent(iconAssetId, forKey: .iconAssetId)
        try container.encodeIfPresent(ipaUuids, forKey: .ipaUuids)
        try container.encodeIfPresent(languages, forKey: .languages)
        try container.encodeIfPresent(minimumOsVersion, forKey: .minimumOsVersion)
        try container.encodeIfPresent(packageURL, forKey: .packageURL)
        try container.encodeIfPresent(provision, forKey: .provision)
        try container.encodeIfPresent(proxyFlow, forKey: .proxyFlow)
        try container.encodeIfPresent(uniqueIdentifier, forKey: .uniqueIdentifier)
        try container.encodeIfPresent(version, forKey: .version)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? ReleaseCreateRequest else { return false }
      guard self.fingerprint == object.fingerprint else { return false }
      guard self.size == object.size else { return false }
      guard self.uploadId == object.uploadId else { return false }
      guard self.appexProvisioningProfiles == object.appexProvisioningProfiles else { return false }
      guard self.buildVersion == object.buildVersion else { return false }
      guard self.deviceFamily == object.deviceFamily else { return false }
      guard self.fileExtension == object.fileExtension else { return false }
      guard self.iconAssetId == object.iconAssetId else { return false }
      guard self.ipaUuids == object.ipaUuids else { return false }
      guard self.languages == object.languages else { return false }
      guard self.minimumOsVersion == object.minimumOsVersion else { return false }
      guard self.packageURL == object.packageURL else { return false }
      guard self.provision == object.provision else { return false }
      guard self.proxyFlow == object.proxyFlow else { return false }
      guard self.uniqueIdentifier == object.uniqueIdentifier else { return false }
      guard self.version == object.version else { return false }
      return true
    }

    public static func == (lhs: ReleaseCreateRequest, rhs: ReleaseCreateRequest) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
