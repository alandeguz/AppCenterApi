//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Represents database usage metrics. */
public class DatabaseMetrics: APIModel {

    public var dataUsage: Double?

    public var indexUsage: Double?

    public var interval: Int?

    public var latencyMetrics: LatencyMetrics?

    public var totalRequestUnits: Double?

    public var totalRequests: Double?

    /** Represents database usage metrics. */
    public class LatencyMetrics: APIModel {

        public var readLatencyMetrics: ReadLatencyMetrics?

        public var writeLatencyMetrics: WriteLatencyMetrics?

        /** Represents database usage metrics. */
        public class ReadLatencyMetrics: APIModel {

            public var endTime: DateTime?

            public var metricValues: [MetricValues]?

            public var name: String?

            public var startTime: DateTime?

            public var unit: String?

            public init(endTime: DateTime? = nil, metricValues: [MetricValues]? = nil, name: String? = nil, startTime: DateTime? = nil, unit: String? = nil) {
                self.endTime = endTime
                self.metricValues = metricValues
                self.name = name
                self.startTime = startTime
                self.unit = unit
            }

            private enum CodingKeys: String, CodingKey {
                case endTime
                case metricValues
                case name
                case startTime
                case unit
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                endTime = try container.decodeIfPresent(.endTime)
                metricValues = try container.decodeArrayIfPresent(.metricValues)
                name = try container.decodeIfPresent(.name)
                startTime = try container.decodeIfPresent(.startTime)
                unit = try container.decodeIfPresent(.unit)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(endTime, forKey: .endTime)
                try container.encodeIfPresent(metricValues, forKey: .metricValues)
                try container.encodeIfPresent(name, forKey: .name)
                try container.encodeIfPresent(startTime, forKey: .startTime)
                try container.encodeIfPresent(unit, forKey: .unit)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? ReadLatencyMetrics else { return false }
              guard self.endTime == object.endTime else { return false }
              guard self.metricValues == object.metricValues else { return false }
              guard self.name == object.name else { return false }
              guard self.startTime == object.startTime else { return false }
              guard self.unit == object.unit else { return false }
              return true
            }

            public static func == (lhs: ReadLatencyMetrics, rhs: ReadLatencyMetrics) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        /** Represents database usage metrics. */
        public class WriteLatencyMetrics: APIModel {

            public var endTime: DateTime?

            public var metricValues: [MetricValues]?

            public var name: String?

            public var startTime: DateTime?

            public var unit: String?

            public init(endTime: DateTime? = nil, metricValues: [MetricValues]? = nil, name: String? = nil, startTime: DateTime? = nil, unit: String? = nil) {
                self.endTime = endTime
                self.metricValues = metricValues
                self.name = name
                self.startTime = startTime
                self.unit = unit
            }

            private enum CodingKeys: String, CodingKey {
                case endTime
                case metricValues
                case name
                case startTime
                case unit
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                endTime = try container.decodeIfPresent(.endTime)
                metricValues = try container.decodeArrayIfPresent(.metricValues)
                name = try container.decodeIfPresent(.name)
                startTime = try container.decodeIfPresent(.startTime)
                unit = try container.decodeIfPresent(.unit)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(endTime, forKey: .endTime)
                try container.encodeIfPresent(metricValues, forKey: .metricValues)
                try container.encodeIfPresent(name, forKey: .name)
                try container.encodeIfPresent(startTime, forKey: .startTime)
                try container.encodeIfPresent(unit, forKey: .unit)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? WriteLatencyMetrics else { return false }
              guard self.endTime == object.endTime else { return false }
              guard self.metricValues == object.metricValues else { return false }
              guard self.name == object.name else { return false }
              guard self.startTime == object.startTime else { return false }
              guard self.unit == object.unit else { return false }
              return true
            }

            public static func == (lhs: WriteLatencyMetrics, rhs: WriteLatencyMetrics) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(readLatencyMetrics: ReadLatencyMetrics? = nil, writeLatencyMetrics: WriteLatencyMetrics? = nil) {
            self.readLatencyMetrics = readLatencyMetrics
            self.writeLatencyMetrics = writeLatencyMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case readLatencyMetrics
            case writeLatencyMetrics
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            readLatencyMetrics = try container.decodeIfPresent(.readLatencyMetrics)
            writeLatencyMetrics = try container.decodeIfPresent(.writeLatencyMetrics)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(readLatencyMetrics, forKey: .readLatencyMetrics)
            try container.encodeIfPresent(writeLatencyMetrics, forKey: .writeLatencyMetrics)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? LatencyMetrics else { return false }
          guard self.readLatencyMetrics == object.readLatencyMetrics else { return false }
          guard self.writeLatencyMetrics == object.writeLatencyMetrics else { return false }
          return true
        }

        public static func == (lhs: LatencyMetrics, rhs: LatencyMetrics) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(dataUsage: Double? = nil, indexUsage: Double? = nil, interval: Int? = nil, latencyMetrics: LatencyMetrics? = nil, totalRequestUnits: Double? = nil, totalRequests: Double? = nil) {
        self.dataUsage = dataUsage
        self.indexUsage = indexUsage
        self.interval = interval
        self.latencyMetrics = latencyMetrics
        self.totalRequestUnits = totalRequestUnits
        self.totalRequests = totalRequests
    }

    private enum CodingKeys: String, CodingKey {
        case dataUsage
        case indexUsage
        case interval
        case latencyMetrics
        case totalRequestUnits
        case totalRequests
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        dataUsage = try container.decodeIfPresent(.dataUsage)
        indexUsage = try container.decodeIfPresent(.indexUsage)
        interval = try container.decodeIfPresent(.interval)
        latencyMetrics = try container.decodeIfPresent(.latencyMetrics)
        totalRequestUnits = try container.decodeIfPresent(.totalRequestUnits)
        totalRequests = try container.decodeIfPresent(.totalRequests)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(dataUsage, forKey: .dataUsage)
        try container.encodeIfPresent(indexUsage, forKey: .indexUsage)
        try container.encodeIfPresent(interval, forKey: .interval)
        try container.encodeIfPresent(latencyMetrics, forKey: .latencyMetrics)
        try container.encodeIfPresent(totalRequestUnits, forKey: .totalRequestUnits)
        try container.encodeIfPresent(totalRequests, forKey: .totalRequests)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? DatabaseMetrics else { return false }
      guard self.dataUsage == object.dataUsage else { return false }
      guard self.indexUsage == object.indexUsage else { return false }
      guard self.interval == object.interval else { return false }
      guard self.latencyMetrics == object.latencyMetrics else { return false }
      guard self.totalRequestUnits == object.totalRequestUnits else { return false }
      guard self.totalRequests == object.totalRequests else { return false }
      return true
    }

    public static func == (lhs: DatabaseMetrics, rhs: DatabaseMetrics) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
