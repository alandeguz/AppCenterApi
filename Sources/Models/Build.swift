//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class Build: APIModel {

    /** The build ID */
    public var id: Int

    /** The build number */
    public var buildNumber: String

    /** The time the build was queued */
    public var queueTime: String

    /** The build status */
    public var status: String

    /** The build result */
    public var result: String

    /** The source branch name */
    public var sourceBranch: String

    /** The source SHA */
    public var sourceVersion: String

    /** The time the build was finished */
    public var finishTime: String?

    /** The time the build status was last changed */
    public var lastChangedDate: String?

    /** The time the build was started */
    public var startTime: String?

    public init(id: Int, buildNumber: String, queueTime: String, status: String, result: String, sourceBranch: String, sourceVersion: String, finishTime: String? = nil, lastChangedDate: String? = nil, startTime: String? = nil) {
        self.id = id
        self.buildNumber = buildNumber
        self.queueTime = queueTime
        self.status = status
        self.result = result
        self.sourceBranch = sourceBranch
        self.sourceVersion = sourceVersion
        self.finishTime = finishTime
        self.lastChangedDate = lastChangedDate
        self.startTime = startTime
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case buildNumber
        case queueTime
        case status
        case result
        case sourceBranch
        case sourceVersion
        case finishTime
        case lastChangedDate
        case startTime
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decode(.id)
        buildNumber = try container.decode(.buildNumber)
        queueTime = try container.decode(.queueTime)
        status = try container.decode(.status)
        result = try container.decode(.result)
        sourceBranch = try container.decode(.sourceBranch)
        sourceVersion = try container.decode(.sourceVersion)
        finishTime = try container.decodeIfPresent(.finishTime)
        lastChangedDate = try container.decodeIfPresent(.lastChangedDate)
        startTime = try container.decodeIfPresent(.startTime)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(id, forKey: .id)
        try container.encode(buildNumber, forKey: .buildNumber)
        try container.encode(queueTime, forKey: .queueTime)
        try container.encode(status, forKey: .status)
        try container.encode(result, forKey: .result)
        try container.encode(sourceBranch, forKey: .sourceBranch)
        try container.encode(sourceVersion, forKey: .sourceVersion)
        try container.encodeIfPresent(finishTime, forKey: .finishTime)
        try container.encodeIfPresent(lastChangedDate, forKey: .lastChangedDate)
        try container.encodeIfPresent(startTime, forKey: .startTime)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? Build else { return false }
      guard self.id == object.id else { return false }
      guard self.buildNumber == object.buildNumber else { return false }
      guard self.queueTime == object.queueTime else { return false }
      guard self.status == object.status else { return false }
      guard self.result == object.result else { return false }
      guard self.sourceBranch == object.sourceBranch else { return false }
      guard self.sourceVersion == object.sourceVersion else { return false }
      guard self.finishTime == object.finishTime else { return false }
      guard self.lastChangedDate == object.lastChangedDate else { return false }
      guard self.startTime == object.startTime else { return false }
      return true
    }

    public static func == (lhs: Build, rhs: Build) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
