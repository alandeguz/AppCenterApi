//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods and Watches from Apple Developer Portal */
public class AvailabilityOfDevicesResponse: APIModel {

    /** ... */
    public var iphones: Iphones

    /** ... */
    public var ipads: Ipads

    /** ... */
    public var ipods: Ipods

    /** ... */
    public var watches: Watches

    /** The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods and Watches from Apple Developer Portal */
    public class Iphones: APIModel {

        public var registered: Double

        public var available: Double

        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }

        private enum CodingKeys: String, CodingKey {
            case registered
            case available
            case maximum
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            registered = try container.decode(.registered)
            available = try container.decode(.available)
            maximum = try container.decode(.maximum)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(registered, forKey: .registered)
            try container.encode(available, forKey: .available)
            try container.encode(maximum, forKey: .maximum)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Iphones else { return false }
          guard self.registered == object.registered else { return false }
          guard self.available == object.available else { return false }
          guard self.maximum == object.maximum else { return false }
          return true
        }

        public static func == (lhs: Iphones, rhs: Iphones) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods and Watches from Apple Developer Portal */
    public class Ipads: APIModel {

        public var registered: Double

        public var available: Double

        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }

        private enum CodingKeys: String, CodingKey {
            case registered
            case available
            case maximum
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            registered = try container.decode(.registered)
            available = try container.decode(.available)
            maximum = try container.decode(.maximum)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(registered, forKey: .registered)
            try container.encode(available, forKey: .available)
            try container.encode(maximum, forKey: .maximum)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Ipads else { return false }
          guard self.registered == object.registered else { return false }
          guard self.available == object.available else { return false }
          guard self.maximum == object.maximum else { return false }
          return true
        }

        public static func == (lhs: Ipads, rhs: Ipads) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods and Watches from Apple Developer Portal */
    public class Ipods: APIModel {

        public var registered: Double

        public var available: Double

        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }

        private enum CodingKeys: String, CodingKey {
            case registered
            case available
            case maximum
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            registered = try container.decode(.registered)
            available = try container.decode(.available)
            maximum = try container.decode(.maximum)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(registered, forKey: .registered)
            try container.encode(available, forKey: .available)
            try container.encode(maximum, forKey: .maximum)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Ipods else { return false }
          guard self.registered == object.registered else { return false }
          guard self.available == object.available else { return false }
          guard self.maximum == object.maximum else { return false }
          return true
        }

        public static func == (lhs: Ipods, rhs: Ipods) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    /** The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods and Watches from Apple Developer Portal */
    public class Watches: APIModel {

        public var registered: Double

        public var available: Double

        public var maximum: Double

        public init(registered: Double, available: Double, maximum: Double) {
            self.registered = registered
            self.available = available
            self.maximum = maximum
        }

        private enum CodingKeys: String, CodingKey {
            case registered
            case available
            case maximum
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            registered = try container.decode(.registered)
            available = try container.decode(.available)
            maximum = try container.decode(.maximum)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encode(registered, forKey: .registered)
            try container.encode(available, forKey: .available)
            try container.encode(maximum, forKey: .maximum)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Watches else { return false }
          guard self.registered == object.registered else { return false }
          guard self.available == object.available else { return false }
          guard self.maximum == object.maximum else { return false }
          return true
        }

        public static func == (lhs: Watches, rhs: Watches) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(iphones: Iphones, ipads: Ipads, ipods: Ipods, watches: Watches) {
        self.iphones = iphones
        self.ipads = ipads
        self.ipods = ipods
        self.watches = watches
    }

    private enum CodingKeys: String, CodingKey {
        case iphones
        case ipads
        case ipods
        case watches
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        iphones = try container.decode(.iphones)
        ipads = try container.decode(.ipads)
        ipods = try container.decode(.ipods)
        watches = try container.decode(.watches)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(iphones, forKey: .iphones)
        try container.encode(ipads, forKey: .ipads)
        try container.encode(ipods, forKey: .ipods)
        try container.encode(watches, forKey: .watches)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? AvailabilityOfDevicesResponse else { return false }
      guard self.iphones == object.iphones else { return false }
      guard self.ipads == object.ipads else { return false }
      guard self.ipods == object.ipods else { return false }
      guard self.watches == object.watches else { return false }
      return true
    }

    public static func == (lhs: AvailabilityOfDevicesResponse, rhs: AvailabilityOfDevicesResponse) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
