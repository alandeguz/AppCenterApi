//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Details of an uploaded release */
public class StoresReleaseDetails: APIModel {

    /** The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=` */
    public enum InstallURL: String, Codable {
        case group = "group"
        case store = "store"

        public static let cases: [InstallURL] = [
          .group,
          .store,
        ]
    }

    /** OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
    The release state.<br>
    <b>available</b>: The uploaded release has been distributed.<br>
    <b>unavailable</b>: The uploaded release is not visible to the user. <br>
     */
    public enum Status: String, Codable {
        case available = "available"
        case unavailable = "unavailable"

        public static let cases: [Status] = [
          .available,
          .unavailable,
        ]
    }

    /** The release's minimum required Android API level. */
    public var androidMinApiLevel: String?

    /** The app's display name. */
    public var appDisplayName: String?

    /** The app's name (extracted from the uploaded release). */
    public var appName: String?

    /** The identifier of the apps bundle. */
    public var bundleIdentifier: String?

    /** a list of distribution stores that are associated with this release. */
    public var distributionStores: [DistributionStores]?

    /** The URL that hosts the binary for this release. */
    public var downloadURL: String?

    /** MD5 checksum of the release binary. */
    public var fingerprint: String?

    /** ID identifying this unique release. */
    public var id: Double?

    /** The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=` */
    public var installURL: InstallURL?

    /** The release's minimum required operating system. */
    public var minOs: String?

    /** The release's release notes. */
    public var releaseNotes: String?

    /** The release's short version.<br>
For iOS: CFBundleShortVersionString from info.plist.
For Android: android:versionName from AppManifest.xml.
 */
    public var shortVersion: String?

    /** The release's size in bytes. */
    public var size: Double?

    /** OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
The release state.<br>
<b>available</b>: The uploaded release has been distributed.<br>
<b>unavailable</b>: The uploaded release is not visible to the user. <br>
 */
    public var status: Status?

    /** UTC time in ISO 8601 format of the uploaded time. */
    public var uploadedAt: String?

    /** The release's version.<br>
For iOS: CFBundleVersion from info.plist.
For Android: android:versionCode from AppManifest.xml.
 */
    public var version: String?

    public init(androidMinApiLevel: String? = nil, appDisplayName: String? = nil, appName: String? = nil, bundleIdentifier: String? = nil, distributionStores: [DistributionStores]? = nil, downloadURL: String? = nil, fingerprint: String? = nil, id: Double? = nil, installURL: InstallURL? = nil, minOs: String? = nil, releaseNotes: String? = nil, shortVersion: String? = nil, size: Double? = nil, status: Status? = nil, uploadedAt: String? = nil, version: String? = nil) {
        self.androidMinApiLevel = androidMinApiLevel
        self.appDisplayName = appDisplayName
        self.appName = appName
        self.bundleIdentifier = bundleIdentifier
        self.distributionStores = distributionStores
        self.downloadURL = downloadURL
        self.fingerprint = fingerprint
        self.id = id
        self.installURL = installURL
        self.minOs = minOs
        self.releaseNotes = releaseNotes
        self.shortVersion = shortVersion
        self.size = size
        self.status = status
        self.uploadedAt = uploadedAt
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case androidMinApiLevel = "android_min_api_level"
        case appDisplayName = "app_display_name"
        case appName = "app_name"
        case bundleIdentifier = "bundle_identifier"
        case distributionStores = "distribution_stores"
        case downloadURL = "download_url"
        case fingerprint
        case id
        case installURL = "install_url"
        case minOs = "min_os"
        case releaseNotes = "release_notes"
        case shortVersion = "short_version"
        case size
        case status
        case uploadedAt = "uploaded_at"
        case version
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        androidMinApiLevel = try container.decodeIfPresent(.androidMinApiLevel)
        appDisplayName = try container.decodeIfPresent(.appDisplayName)
        appName = try container.decodeIfPresent(.appName)
        bundleIdentifier = try container.decodeIfPresent(.bundleIdentifier)
        distributionStores = try container.decodeArrayIfPresent(.distributionStores)
        downloadURL = try container.decodeIfPresent(.downloadURL)
        fingerprint = try container.decodeIfPresent(.fingerprint)
        id = try container.decodeIfPresent(.id)
        installURL = try container.decodeIfPresent(.installURL)
        minOs = try container.decodeIfPresent(.minOs)
        releaseNotes = try container.decodeIfPresent(.releaseNotes)
        shortVersion = try container.decodeIfPresent(.shortVersion)
        size = try container.decodeIfPresent(.size)
        status = try container.decodeIfPresent(.status)
        uploadedAt = try container.decodeIfPresent(.uploadedAt)
        version = try container.decodeIfPresent(.version)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(androidMinApiLevel, forKey: .androidMinApiLevel)
        try container.encodeIfPresent(appDisplayName, forKey: .appDisplayName)
        try container.encodeIfPresent(appName, forKey: .appName)
        try container.encodeIfPresent(bundleIdentifier, forKey: .bundleIdentifier)
        try container.encodeIfPresent(distributionStores, forKey: .distributionStores)
        try container.encodeIfPresent(downloadURL, forKey: .downloadURL)
        try container.encodeIfPresent(fingerprint, forKey: .fingerprint)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(installURL, forKey: .installURL)
        try container.encodeIfPresent(minOs, forKey: .minOs)
        try container.encodeIfPresent(releaseNotes, forKey: .releaseNotes)
        try container.encodeIfPresent(shortVersion, forKey: .shortVersion)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(uploadedAt, forKey: .uploadedAt)
        try container.encodeIfPresent(version, forKey: .version)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? StoresReleaseDetails else { return false }
      guard self.androidMinApiLevel == object.androidMinApiLevel else { return false }
      guard self.appDisplayName == object.appDisplayName else { return false }
      guard self.appName == object.appName else { return false }
      guard self.bundleIdentifier == object.bundleIdentifier else { return false }
      guard self.distributionStores == object.distributionStores else { return false }
      guard self.downloadURL == object.downloadURL else { return false }
      guard self.fingerprint == object.fingerprint else { return false }
      guard self.id == object.id else { return false }
      guard self.installURL == object.installURL else { return false }
      guard self.minOs == object.minOs else { return false }
      guard self.releaseNotes == object.releaseNotes else { return false }
      guard self.shortVersion == object.shortVersion else { return false }
      guard self.size == object.size else { return false }
      guard self.status == object.status else { return false }
      guard self.uploadedAt == object.uploadedAt else { return false }
      guard self.version == object.version else { return false }
      return true
    }

    public static func == (lhs: StoresReleaseDetails, rhs: StoresReleaseDetails) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
