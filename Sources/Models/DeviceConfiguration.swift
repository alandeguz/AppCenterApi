//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class DeviceConfiguration: APIModel {

    /** The unique id of the device configuration */
    public var id: ID?

    public var image: Image?

    public var marketShare: Double?

    public var model: Model?

    /** The name of the device model and OS version */
    public var name: String?

    public var os: String?

    public var osName: String?

    /** The tier */
    public var tier: Double?

    public class Image: APIModel {

        public var full: String?

        public var thumb: String?

        public init(full: String? = nil, thumb: String? = nil) {
            self.full = full
            self.thumb = thumb
        }

        private enum CodingKeys: String, CodingKey {
            case full
            case thumb
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            full = try container.decodeIfPresent(.full)
            thumb = try container.decodeIfPresent(.thumb)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(full, forKey: .full)
            try container.encodeIfPresent(thumb, forKey: .thumb)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Image else { return false }
          guard self.full == object.full else { return false }
          guard self.thumb == object.thumb else { return false }
          return true
        }

        public static func == (lhs: Image, rhs: Image) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class Model: APIModel {

        public var availabilityCount: Double?

        /** CPU data for device */
        public var cpu: Cpu?

        public var deviceFrame: DeviceFrame?

        /** Physical device dimensions */
        public var dimensions: Dimensions?

        public var formFactor: String?

        public var manufacturer: String?

        /** Memory data for device */
        public var memory: Memory?

        public var model: String?

        public var name: String?

        public var platform: String?

        public var releaseDate: String?

        /** Device screen resolution */
        public var resolution: Resolution?

        public var screenRotation: Double?

        /** Physical device screen dimensions */
        public var screenSize: ScreenSize?

        public class Cpu: APIModel {

            public var core: String?

            public var frequency: String?

            public var text: String?

            public init(core: String? = nil, frequency: String? = nil, text: String? = nil) {
                self.core = core
                self.frequency = frequency
                self.text = text
            }

            private enum CodingKeys: String, CodingKey {
                case core
                case frequency
                case text
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                core = try container.decodeIfPresent(.core)
                frequency = try container.decodeIfPresent(.frequency)
                text = try container.decodeIfPresent(.text)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(core, forKey: .core)
                try container.encodeIfPresent(frequency, forKey: .frequency)
                try container.encodeIfPresent(text, forKey: .text)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Cpu else { return false }
              guard self.core == object.core else { return false }
              guard self.frequency == object.frequency else { return false }
              guard self.text == object.text else { return false }
              return true
            }

            public static func == (lhs: Cpu, rhs: Cpu) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public class DeviceFrame: APIModel {

            public var full: Full?

            public var grid: Grid?

            public class Full: APIModel {

                public var frameUrl: String?

                public var height: Double?

                public var screen: [Double]?

                public var width: Double?

                public init(frameUrl: String? = nil, height: Double? = nil, screen: [Double]? = nil, width: Double? = nil) {
                    self.frameUrl = frameUrl
                    self.height = height
                    self.screen = screen
                    self.width = width
                }

                private enum CodingKeys: String, CodingKey {
                    case frameUrl
                    case height
                    case screen
                    case width
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    frameUrl = try container.decodeIfPresent(.frameUrl)
                    height = try container.decodeIfPresent(.height)
                    screen = try container.decodeArrayIfPresent(.screen)
                    width = try container.decodeIfPresent(.width)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(frameUrl, forKey: .frameUrl)
                    try container.encodeIfPresent(height, forKey: .height)
                    try container.encodeIfPresent(screen, forKey: .screen)
                    try container.encodeIfPresent(width, forKey: .width)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Full else { return false }
                  guard self.frameUrl == object.frameUrl else { return false }
                  guard self.height == object.height else { return false }
                  guard self.screen == object.screen else { return false }
                  guard self.width == object.width else { return false }
                  return true
                }

                public static func == (lhs: Full, rhs: Full) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public class Grid: APIModel {

                public var frameUrl: String?

                public var height: Double?

                public var screen: [Double]?

                public var width: Double?

                public init(frameUrl: String? = nil, height: Double? = nil, screen: [Double]? = nil, width: Double? = nil) {
                    self.frameUrl = frameUrl
                    self.height = height
                    self.screen = screen
                    self.width = width
                }

                private enum CodingKeys: String, CodingKey {
                    case frameUrl
                    case height
                    case screen
                    case width
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)

                    frameUrl = try container.decodeIfPresent(.frameUrl)
                    height = try container.decodeIfPresent(.height)
                    screen = try container.decodeArrayIfPresent(.screen)
                    width = try container.decodeIfPresent(.width)
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)

                    try container.encodeIfPresent(frameUrl, forKey: .frameUrl)
                    try container.encodeIfPresent(height, forKey: .height)
                    try container.encodeIfPresent(screen, forKey: .screen)
                    try container.encodeIfPresent(width, forKey: .width)
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Grid else { return false }
                  guard self.frameUrl == object.frameUrl else { return false }
                  guard self.height == object.height else { return false }
                  guard self.screen == object.screen else { return false }
                  guard self.width == object.width else { return false }
                  return true
                }

                public static func == (lhs: Grid, rhs: Grid) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public init(full: Full? = nil, grid: Grid? = nil) {
                self.full = full
                self.grid = grid
            }

            private enum CodingKeys: String, CodingKey {
                case full
                case grid
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                full = try container.decodeIfPresent(.full)
                grid = try container.decodeIfPresent(.grid)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(full, forKey: .full)
                try container.encodeIfPresent(grid, forKey: .grid)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? DeviceFrame else { return false }
              guard self.full == object.full else { return false }
              guard self.grid == object.grid else { return false }
              return true
            }

            public static func == (lhs: DeviceFrame, rhs: DeviceFrame) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public class Dimensions: APIModel {

            public var depth: [String: Any]?

            public var height: [String: Any]?

            public var width: [String: Any]?

            public init(depth: [String: Any]? = nil, height: [String: Any]? = nil, width: [String: Any]? = nil) {
                self.depth = depth
                self.height = height
                self.width = width
            }

            private enum CodingKeys: String, CodingKey {
                case depth
                case height
                case width
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                depth = try container.decodeAnyIfPresent(.depth)
                height = try container.decodeAnyIfPresent(.height)
                width = try container.decodeAnyIfPresent(.width)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeAnyIfPresent(depth, forKey: .depth)
                try container.encodeAnyIfPresent(height, forKey: .height)
                try container.encodeAnyIfPresent(width, forKey: .width)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Dimensions else { return false }
              guard NSDictionary(dictionary: self.depth ?? [:]).isEqual(to: object.depth ?? [:]) else { return false }
              guard NSDictionary(dictionary: self.height ?? [:]).isEqual(to: object.height ?? [:]) else { return false }
              guard NSDictionary(dictionary: self.width ?? [:]).isEqual(to: object.width ?? [:]) else { return false }
              return true
            }

            public static func == (lhs: Dimensions, rhs: Dimensions) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public class Memory: APIModel {

            public var formattedSize: String?

            public init(formattedSize: String? = nil) {
                self.formattedSize = formattedSize
            }

            private enum CodingKeys: String, CodingKey {
                case formattedSize
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                formattedSize = try container.decodeIfPresent(.formattedSize)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(formattedSize, forKey: .formattedSize)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Memory else { return false }
              guard self.formattedSize == object.formattedSize else { return false }
              return true
            }

            public static func == (lhs: Memory, rhs: Memory) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public class Resolution: APIModel {

            public var height: String?

            public var ppi: String?

            public var width: String?

            public init(height: String? = nil, ppi: String? = nil, width: String? = nil) {
                self.height = height
                self.ppi = ppi
                self.width = width
            }

            private enum CodingKeys: String, CodingKey {
                case height
                case ppi
                case width
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                height = try container.decodeIfPresent(.height)
                ppi = try container.decodeIfPresent(.ppi)
                width = try container.decodeIfPresent(.width)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(height, forKey: .height)
                try container.encodeIfPresent(ppi, forKey: .ppi)
                try container.encodeIfPresent(width, forKey: .width)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Resolution else { return false }
              guard self.height == object.height else { return false }
              guard self.ppi == object.ppi else { return false }
              guard self.width == object.width else { return false }
              return true
            }

            public static func == (lhs: Resolution, rhs: Resolution) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public class ScreenSize: APIModel {

            public var cm: String?

            public var `in`: String?

            public init(cm: String? = nil, `in`: String? = nil) {
                self.cm = cm
                self.`in` = `in`
            }

            private enum CodingKeys: String, CodingKey {
                case cm
                case `in` = "in"
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                cm = try container.decodeIfPresent(.cm)
                `in` = try container.decodeIfPresent(.`in`)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                try container.encodeIfPresent(cm, forKey: .cm)
                try container.encodeIfPresent(`in`, forKey: .`in`)
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? ScreenSize else { return false }
              guard self.cm == object.cm else { return false }
              guard self.`in` == object.`in` else { return false }
              return true
            }

            public static func == (lhs: ScreenSize, rhs: ScreenSize) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(availabilityCount: Double? = nil, cpu: Cpu? = nil, deviceFrame: DeviceFrame? = nil, dimensions: Dimensions? = nil, formFactor: String? = nil, manufacturer: String? = nil, memory: Memory? = nil, model: String? = nil, name: String? = nil, platform: String? = nil, releaseDate: String? = nil, resolution: Resolution? = nil, screenRotation: Double? = nil, screenSize: ScreenSize? = nil) {
            self.availabilityCount = availabilityCount
            self.cpu = cpu
            self.deviceFrame = deviceFrame
            self.dimensions = dimensions
            self.formFactor = formFactor
            self.manufacturer = manufacturer
            self.memory = memory
            self.model = model
            self.name = name
            self.platform = platform
            self.releaseDate = releaseDate
            self.resolution = resolution
            self.screenRotation = screenRotation
            self.screenSize = screenSize
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityCount
            case cpu
            case deviceFrame
            case dimensions
            case formFactor
            case manufacturer
            case memory
            case model
            case name
            case platform
            case releaseDate
            case resolution
            case screenRotation
            case screenSize
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            availabilityCount = try container.decodeIfPresent(.availabilityCount)
            cpu = try container.decodeIfPresent(.cpu)
            deviceFrame = try container.decodeIfPresent(.deviceFrame)
            dimensions = try container.decodeIfPresent(.dimensions)
            formFactor = try container.decodeIfPresent(.formFactor)
            manufacturer = try container.decodeIfPresent(.manufacturer)
            memory = try container.decodeIfPresent(.memory)
            model = try container.decodeIfPresent(.model)
            name = try container.decodeIfPresent(.name)
            platform = try container.decodeIfPresent(.platform)
            releaseDate = try container.decodeIfPresent(.releaseDate)
            resolution = try container.decodeIfPresent(.resolution)
            screenRotation = try container.decodeIfPresent(.screenRotation)
            screenSize = try container.decodeIfPresent(.screenSize)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(availabilityCount, forKey: .availabilityCount)
            try container.encodeIfPresent(cpu, forKey: .cpu)
            try container.encodeIfPresent(deviceFrame, forKey: .deviceFrame)
            try container.encodeIfPresent(dimensions, forKey: .dimensions)
            try container.encodeIfPresent(formFactor, forKey: .formFactor)
            try container.encodeIfPresent(manufacturer, forKey: .manufacturer)
            try container.encodeIfPresent(memory, forKey: .memory)
            try container.encodeIfPresent(model, forKey: .model)
            try container.encodeIfPresent(name, forKey: .name)
            try container.encodeIfPresent(platform, forKey: .platform)
            try container.encodeIfPresent(releaseDate, forKey: .releaseDate)
            try container.encodeIfPresent(resolution, forKey: .resolution)
            try container.encodeIfPresent(screenRotation, forKey: .screenRotation)
            try container.encodeIfPresent(screenSize, forKey: .screenSize)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Model else { return false }
          guard self.availabilityCount == object.availabilityCount else { return false }
          guard self.cpu == object.cpu else { return false }
          guard self.deviceFrame == object.deviceFrame else { return false }
          guard self.dimensions == object.dimensions else { return false }
          guard self.formFactor == object.formFactor else { return false }
          guard self.manufacturer == object.manufacturer else { return false }
          guard self.memory == object.memory else { return false }
          guard self.model == object.model else { return false }
          guard self.name == object.name else { return false }
          guard self.platform == object.platform else { return false }
          guard self.releaseDate == object.releaseDate else { return false }
          guard self.resolution == object.resolution else { return false }
          guard self.screenRotation == object.screenRotation else { return false }
          guard self.screenSize == object.screenSize else { return false }
          return true
        }

        public static func == (lhs: Model, rhs: Model) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(id: ID? = nil, image: Image? = nil, marketShare: Double? = nil, model: Model? = nil, name: String? = nil, os: String? = nil, osName: String? = nil, tier: Double? = nil) {
        self.id = id
        self.image = image
        self.marketShare = marketShare
        self.model = model
        self.name = name
        self.os = os
        self.osName = osName
        self.tier = tier
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case image
        case marketShare
        case model
        case name
        case os
        case osName
        case tier
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decodeIfPresent(.id)
        image = try container.decodeIfPresent(.image)
        marketShare = try container.decodeIfPresent(.marketShare)
        model = try container.decodeIfPresent(.model)
        name = try container.decodeIfPresent(.name)
        os = try container.decodeIfPresent(.os)
        osName = try container.decodeIfPresent(.osName)
        tier = try container.decodeIfPresent(.tier)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(image, forKey: .image)
        try container.encodeIfPresent(marketShare, forKey: .marketShare)
        try container.encodeIfPresent(model, forKey: .model)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(os, forKey: .os)
        try container.encodeIfPresent(osName, forKey: .osName)
        try container.encodeIfPresent(tier, forKey: .tier)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? DeviceConfiguration else { return false }
      guard self.id == object.id else { return false }
      guard self.image == object.image else { return false }
      guard self.marketShare == object.marketShare else { return false }
      guard self.model == object.model else { return false }
      guard self.name == object.name else { return false }
      guard self.os == object.os else { return false }
      guard self.osName == object.osName else { return false }
      guard self.tier == object.tier else { return false }
      return true
    }

    public static func == (lhs: DeviceConfiguration, rhs: DeviceConfiguration) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
