//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class LegacyDeployment: APIModel {

    /** Updated deployment name */
    public var name: String

    /** Time at which the deployment was created as a Unix timestamp. */
    public var createdTime: Int?

    /** The ID of the deployment (internal use only). */
    public var id: String?

    /** Deployment key (aka Deployment Id) */
    public var key: String?

    public var package: Package?

    public class Package: APIModel {

        /** The version of the release */
        public var appVersion: String?

        /** Location (URL) of release package */
        public var blobUrl: String?

        /** Object containing URL and size of changed package hashes contained in the release */
        public var diffPackageMap: [String: Any]?

        /** Flag used to determine if release is disabled */
        public var isDisabled: Bool?

        /** Flag used to determine if release is mandatory */
        public var isMandatory: Bool?

        /** Release label (aka release name) */
        public var label: String?

        /** The URL location of the package's manifest file. */
        public var manifestBlobUrl: String?

        /** Method used to deploy release */
        public var releaseMethod: String?

        /** User ID that triggered most recent release */
        public var releasedByUserId: String?

        /** Percentage (out of 100) that release is deployed to */
        public var rollout: Int?

        /** Size of release package */
        public var size: Int?

        /** Release upload time as epoch Unix timestamp */
        public var uploadTime: Int?

        public init(appVersion: String? = nil, blobUrl: String? = nil, diffPackageMap: [String: Any]? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, label: String? = nil, manifestBlobUrl: String? = nil, releaseMethod: String? = nil, releasedByUserId: String? = nil, rollout: Int? = nil, size: Int? = nil, uploadTime: Int? = nil) {
            self.appVersion = appVersion
            self.blobUrl = blobUrl
            self.diffPackageMap = diffPackageMap
            self.isDisabled = isDisabled
            self.isMandatory = isMandatory
            self.label = label
            self.manifestBlobUrl = manifestBlobUrl
            self.releaseMethod = releaseMethod
            self.releasedByUserId = releasedByUserId
            self.rollout = rollout
            self.size = size
            self.uploadTime = uploadTime
        }

        private enum CodingKeys: String, CodingKey {
            case appVersion
            case blobUrl
            case diffPackageMap
            case isDisabled
            case isMandatory
            case label
            case manifestBlobUrl
            case releaseMethod
            case releasedByUserId
            case rollout
            case size
            case uploadTime
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            appVersion = try container.decodeIfPresent(.appVersion)
            blobUrl = try container.decodeIfPresent(.blobUrl)
            diffPackageMap = try container.decodeAnyIfPresent(.diffPackageMap)
            isDisabled = try container.decodeIfPresent(.isDisabled)
            isMandatory = try container.decodeIfPresent(.isMandatory)
            label = try container.decodeIfPresent(.label)
            manifestBlobUrl = try container.decodeIfPresent(.manifestBlobUrl)
            releaseMethod = try container.decodeIfPresent(.releaseMethod)
            releasedByUserId = try container.decodeIfPresent(.releasedByUserId)
            rollout = try container.decodeIfPresent(.rollout)
            size = try container.decodeIfPresent(.size)
            uploadTime = try container.decodeIfPresent(.uploadTime)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)

            try container.encodeIfPresent(appVersion, forKey: .appVersion)
            try container.encodeIfPresent(blobUrl, forKey: .blobUrl)
            try container.encodeAnyIfPresent(diffPackageMap, forKey: .diffPackageMap)
            try container.encodeIfPresent(isDisabled, forKey: .isDisabled)
            try container.encodeIfPresent(isMandatory, forKey: .isMandatory)
            try container.encodeIfPresent(label, forKey: .label)
            try container.encodeIfPresent(manifestBlobUrl, forKey: .manifestBlobUrl)
            try container.encodeIfPresent(releaseMethod, forKey: .releaseMethod)
            try container.encodeIfPresent(releasedByUserId, forKey: .releasedByUserId)
            try container.encodeIfPresent(rollout, forKey: .rollout)
            try container.encodeIfPresent(size, forKey: .size)
            try container.encodeIfPresent(uploadTime, forKey: .uploadTime)
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Package else { return false }
          guard self.appVersion == object.appVersion else { return false }
          guard self.blobUrl == object.blobUrl else { return false }
          guard NSDictionary(dictionary: self.diffPackageMap ?? [:]).isEqual(to: object.diffPackageMap ?? [:]) else { return false }
          guard self.isDisabled == object.isDisabled else { return false }
          guard self.isMandatory == object.isMandatory else { return false }
          guard self.label == object.label else { return false }
          guard self.manifestBlobUrl == object.manifestBlobUrl else { return false }
          guard self.releaseMethod == object.releaseMethod else { return false }
          guard self.releasedByUserId == object.releasedByUserId else { return false }
          guard self.rollout == object.rollout else { return false }
          guard self.size == object.size else { return false }
          guard self.uploadTime == object.uploadTime else { return false }
          return true
        }

        public static func == (lhs: Package, rhs: Package) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(name: String, createdTime: Int? = nil, id: String? = nil, key: String? = nil, package: Package? = nil) {
        self.name = name
        self.createdTime = createdTime
        self.id = id
        self.key = key
        self.package = package
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case createdTime
        case id
        case key
        case package
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        name = try container.decode(.name)
        createdTime = try container.decodeIfPresent(.createdTime)
        id = try container.decodeIfPresent(.id)
        key = try container.decodeIfPresent(.key)
        package = try container.decodeIfPresent(.package)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(createdTime, forKey: .createdTime)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(key, forKey: .key)
        try container.encodeIfPresent(package, forKey: .package)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? LegacyDeployment else { return false }
      guard self.name == object.name else { return false }
      guard self.createdTime == object.createdTime else { return false }
      guard self.id == object.id else { return false }
      guard self.key == object.key else { return false }
      guard self.package == object.package else { return false }
      return true
    }

    public static func == (lhs: LegacyDeployment, rhs: LegacyDeployment) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
